diff --git a/src/sw/noc_dev/IPCore/include/IPTypes.h b/src/sw/noc_dev/IPCore/include/IPTypes.h
index 0b71e8d61de..e1e7ceec3f4 100755
--- a/src/sw/noc_dev/IPCore/include/IPTypes.h
+++ b/src/sw/noc_dev/IPCore/include/IPTypes.h
@@ -39,6 +39,7 @@
 #include "Rtl_lib.common.h"
 #include "IPTypes.Common.h"
 #include "json/json.hpp"
+#define IP_TCL = 1
 namespace NetSpeed {
 
 using ip_json = nlohmann::json;
diff --git a/src/sw/noc_dev/IPStudio_qt6/GUI/Item/IPConnectivity.cpp b/src/sw/noc_dev/IPStudio_qt6/GUI/Item/IPConnectivity.cpp
index a8236d92ce1..ac9bbc8fa95 100644
--- a/src/sw/noc_dev/IPStudio_qt6/GUI/Item/IPConnectivity.cpp
+++ b/src/sw/noc_dev/IPStudio_qt6/GUI/Item/IPConnectivity.cpp
@@ -21,16 +21,21 @@ IPConnectivity::IPConnectivity(const QPoint& gridPoint, const QString& text, QGr
 
 }
 
-IPConnectivity::IPConnectivity(const NetSpeed::BDS::IntfConn& ifce, const QPointF& gridPoint, QGraphicsItem* parent)
+IPConnectivity::IPConnectivity(const NetSpeed::BDS::IntfConn& ifce, const QPointF& gridPoint, QGraphicsItem* parent, bool group)
 : QSchematic::Connector(::ItemType::OperationConnectorType, gridPoint.toPoint(),
                         QString::fromStdString(ifce.ifce->name.c_str()), parent)
     // TODO: conn.port_name replaced with an empty string. not sure if
     // TODO: conn.port_name is even the correct string to use here
 {
+    g         = group;
     mode = ifce.mode;
     ifceLabel = std::make_shared<QSchematic::Label>();
     ifceLabel->setParentItem(this);
-    ifceLabel->setText(ifce.ifce->name.c_str());
+    if (!group)
+        ifceLabel->setText(ifce.ifce->name.c_str());
+    else {
+        ifceLabel->setText(ifce.name.c_str());
+    }
     ifceLabel->setHighLight(false);
     ifceLabel->setMovable(true);
     label()->setVisible(false);
@@ -256,5 +261,5 @@ QPointF IPConnectivity::getConnectingScenePos() const
 
 const QString IPConnectivity::getInstanceName() const
 {
-    return static_cast<IPInstance*>(parentItem())->getinstanceName();
+        return static_cast<IPInstance*>(parentItem())->getinstanceName();
 }
diff --git a/src/sw/noc_dev/IPStudio_qt6/GUI/Item/IPInstance.cpp b/src/sw/noc_dev/IPStudio_qt6/GUI/Item/IPInstance.cpp
index cc5de660765..be478a34dec 100644
--- a/src/sw/noc_dev/IPStudio_qt6/GUI/Item/IPInstance.cpp
+++ b/src/sw/noc_dev/IPStudio_qt6/GUI/Item/IPInstance.cpp
@@ -1,197 +1,235 @@
-#include "NsTypes.h"
-#include "IPInstance.h"
-#include "IPBasic.h"
-#include "IPObject.h"
-#include "IPConnectivity.h"
-
-#include <QPainter>
-#include <QMenu>
-#include <QGraphicsSceneContextMenuEvent>
-#include <QInputDialog>
-#include <QGraphicsDropShadowEffect>
-
-#include "WireItem/scene.h"
-#include "WireItem/commandnodeaddconnector.h"
-
-#include <QMap>
-#include <QPen>
-#include <QBrush>
-#include <QString>
-#include <QPainter>
-#include <QStyleOptionGraphicsItem>
-
-const QColor COLOR_BODY_FILL = QColor(QStringLiteral("#00CEF1"));
-const QColor COLOR_HIGHLIGHT_BODY_FILL = QColor(QStringLiteral("#66E8FF"));
-const QColor COLOR_BODY_BORDER = QColor(Qt::black);
-const QColor COLOR_HIGHLIGHT_BODY_BORDER = QColor(Qt::red);
-const qreal PEN_WIDTH = 1;
-const qreal PEN_HIGHLIGHT_WIDTH = 3;
-
+#include "NsTypes.h"
+#include "IPInstance.h"
+#include "IPBasic.h"
+#include "IPObject.h"
+#include "IPConnectivity.h"
+
+#include <QPainter>
+#include <QMenu>
+#include <QGraphicsSceneContextMenuEvent>
+#include <QInputDialog>
+#include <QGraphicsDropShadowEffect>
+
+#include "WireItem/scene.h"
+#include "WireItem/commandnodeaddconnector.h"
+
+#include <QMap>
+#include <QPen>
+#include <QBrush>
+#include <QString>
+#include <QPainter>
+#include <QStyleOptionGraphicsItem>
+
+const QColor COLOR_BODY_FILL = QColor(QStringLiteral("#00CEF1"));
+const QColor COLOR_HIGHLIGHT_BODY_FILL = QColor(QStringLiteral("#66E8FF"));
+const QColor COLOR_BODY_BORDER = QColor(Qt::black);
+const QColor COLOR_HIGHLIGHT_BODY_BORDER = QColor(Qt::red);
+const qreal PEN_WIDTH = 1;
+const qreal PEN_HIGHLIGHT_WIDTH = 3;
+
 IPInstance::IPInstance(int type, QGraphicsItem* parent) : QSchematic::Node(type, parent) {
 
-}
-
-IPInstance::IPInstance(const NetSpeed::BDS::Instance* instance, int padding, const QRectF& rect, bool drawConnectionPoint, QGraphicsItem* parent) :
-    QSchematic::Node(Item::NodeType, parent), instance(instance), padding(padding), name(QString::fromStdString(instance->name)),
-    drawConnectionPoint(drawConnectionPoint)
-{
-    if (instance->design) moduleName = instance->design->name.c_str();
-    setSize(rect.width(), rect.height());
-    setAllowMouseResize(true);
-    setAllowMouseRotate(true);
-    setConnectorsMovable(true);
-    setConnectorsSnapPolicy(QSchematic::Connector::NodeSizerectOutline);
+}
+
+IPInstance::IPInstance(const NetSpeed::BDS::Instance* instance, int padding, const QRectF& rect,
+                       bool drawConnectionPoint, QGraphicsItem* parent)
+:
+    QSchematic::Node(Item::NodeType, parent), instance(instance), padding(padding),drawConnectionPoint(drawConnectionPoint)
+{
+    if (instance && instance->design) {
+        moduleName = instance->design->name.c_str();
+        name       = QString::fromStdString(instance->name);
+    }
+    setSize(rect.width(), rect.height());
+    setAllowMouseResize(true);
+    setAllowMouseRotate(true);
+    setConnectorsMovable(true);
+    setConnectorsSnapPolicy(QSchematic::Connector::NodeSizerectOutline);
     setConnectorsSnapToGrid(true);
 }
 
 void IPInstance::mousePressEvent(QGraphicsSceneMouseEvent* event)
-{
-    emit object->updateSelectedItemQtree(name);
+{
+    emit object->updateSelectedItemQtree(name);
     QSchematic::Node::mousePressEvent(event);
 }
 
 void IPInstance::alignConnectorLabels() const
-{
-    for (auto connector : _connectors) {
-        Q_ASSERT(connector);
-        connector->alignLabel();
-        std::static_pointer_cast<IPConnectivity>(connector)->alignInterfaceLabel();
+{
+    for (auto connector : _connectors) {
+        Q_ASSERT(connector);
+        connector->alignLabel();
+        std::static_pointer_cast<IPConnectivity>(connector)->alignInterfaceLabel();
     }
 }
 
-void IPInstance::addConnector(const NetSpeed::BDS::IntfConn& pinConn,
-                              const std::shared_ptr<IPConnectivity>& conn) {
-    QSchematic::Node::addConnector(conn);
+void IPInstance::addConnector(const NetSpeed::BDS::IntfConn& pinConn,
+                              const std::shared_ptr<IPConnectivity>& conn) {
+    QSchematic::Node::addConnector(conn);
     connectors[pinConn] = conn.get();
-}
-
-void IPInstance::paint(QPainter* painter, const QStyleOptionGraphicsItem* option, QWidget* widget)
-{
-    Q_UNUSED(option)
-    Q_UNUSED(widget)
-
-    if (_settings.debug) {
-        painter->drawRect(QRectF(QPoint(), size()).adjusted(-textLength * _settings.gridSize - TEXT_PADDING, -textLength * _settings.gridSize - TEXT_PADDING,
-                                                             textLength * _settings.gridSize + TEXT_PADDING, textLength * _settings.gridSize + TEXT_PADDING));
-    }
-
-    // Brush
-    auto sRect = sizeRect();
-    if (isHighlighted() && drawConnectionPoint) {
-        // Line pen
-        QPen penLine(Qt::red, 5, Qt::DashLine);
-
-        // Line brush
-        QBrush brushLine;
-        brushLine.setStyle(Qt::NoBrush);
-
-        // Draw the connection line
-        painter->setPen(penLine);
-        painter->setBrush(brushLine);
-        painter->drawLine(sRect.center(), mapFromScene(connectionPoint));
-    }
-
-    // Pen
-    QPen pen;
-    if (isHighlighted()) {
-        pen.setColor(COLOR_HIGHLIGHT_BODY_BORDER);
-        pen.setWidth(PEN_HIGHLIGHT_WIDTH);
-    } else {
-        pen.setColor(COLOR_BODY_BORDER);
-        pen.setWidth(PEN_WIDTH);
-    }
-    pen.setStyle(Qt::SolidLine);
-    //Draw the component body
-    painter->setPen(pen);
-    painter->drawRect(sRect);
-    QBrush brush;
-    brush.setStyle(Qt::SolidPattern);
-    if (isHighlighted()) {
-        brush.setColor(COLOR_HIGHLIGHT_BODY_FILL);
-    } else {
-        brush.setColor(COLOR_BODY_FILL);
-    }
-    painter->setPen(Qt::white);
-    painter->setBrush(brush);
-    auto r = sRect.adjusted(padding, padding, -padding, -padding);
-    painter->drawRect(r);
-    if (moduleName.isEmpty()) drawTextFitToRect(r, name, painter);
-    else {
-        drawTextFitToRect(QRectF(r.topLeft(), QSizeF(r.width(), r.height() * 0.66)), name, painter);
-        drawTextFitToRect(QRectF(r.topLeft() + QPointF(0, r.height() * 0.66), QSizeF(r.width(), r.height() * 0.33)), moduleName, painter);
-    }
-
-    // Resize handles
-    if (isSelected() && allowMouseResize()) {
-        paintResizeHandles(*painter);
-    }
-
-    // Rotate handle
-    if (isSelected() && allowMouseRotate()) {
-        paintRotateHandle(*painter);
-    }
-}
-
-void IPInstance::contextMenuEvent(QGraphicsSceneContextMenuEvent* event)
-{
-    // Create the menu
-    QMenu menu;
-    {
-        // Align label
-        QAction* alignConnectorLabels = new QAction;
-        alignConnectorLabels->setText("Align connector labels");
-        connect(alignConnectorLabels, &QAction::triggered, [this] {
-            this->alignConnectorLabels();
-            });
-        // Assemble
-        menu.addAction(alignConnectorLabels);
-
-        menu.addSeparator();
-
-        /* QAction* renameInstance = new QAction;
-        renameInstance->setText("Rename Instance");
-        connect(renameInstance, &QAction::triggered, [this] { this->renameInstance(); });
-        menu.addAction(renameInstance);
-
-        QAction* renameModule = new QAction;
-        renameModule->setText("Rename Module");
-        connect(renameModule, &QAction::triggered, [this] { this->renameModule(); });
-        menu.addAction(renameModule); */
-    }
-    // Sow the menu
-    menu.exec(event->screenPos());
-}
-
-void IPInstance::renameModule() {
-    QInputDialog dialog;
-    QString title = "Rename Module \"" + moduleName + "\"";
-    dialog.setWindowTitle(title);
-    dialog.setLabelText(tr("New Name:"));
-    dialog.setWindowFlags(Qt::Window | Qt::WindowCloseButtonHint | Qt::CustomizeWindowHint);
-    int w = 300 + title.length();
-    dialog.resize(QSize(w, 300));
-    dialog.move(QCursor::pos());
-    if (dialog.exec()) {
-        QString text = dialog.textValue();
-        if (text.length() > 0) {
-            moduleName = text;
-        }
-    }
-}
+}
 
-void IPInstance::renameInstance() {
-    QInputDialog dialog;
-    QString title = "Rename Instance \"" + name + "\"";
-    dialog.setWindowTitle(title);
-    dialog.setLabelText(tr("New Name:"));
-    dialog.setWindowFlags(Qt::Window | Qt::WindowCloseButtonHint | Qt::CustomizeWindowHint);
-    int w = 300 + title.length();
-    dialog.resize(QSize(w, 300));
-    dialog.move(QCursor::pos());
-    if (dialog.exec()) {
-        QString text = dialog.textValue();
-        if (text.length() > 0) {
-            name = text;
-        }
+QRectF IPInstance::newBoundingRect() {
+    QRectF nBoundingRect;
+    qreal padding = 75.0;
+    for (auto* child : childItems()) {
+        nBoundingRect = nBoundingRect.united(child->mapToParent(child->boundingRect()).boundingRect());
+    }
+    prepareGeometryChange();
+    nBoundingRect.adjust(-padding, -padding, padding, padding);
+    return nBoundingRect;
+}
+void IPInstance::paint(QPainter* painter, const QStyleOptionGraphicsItem* option, QWidget* widget)
+{
+    Q_UNUSED(option)
+    Q_UNUSED(widget)
+
+    if (_settings.debug) {
+        painter->drawRect(QRectF(QPoint(), size()).adjusted(-textLength * _settings.gridSize - TEXT_PADDING, -textLength * _settings.gridSize - TEXT_PADDING,
+                                                             textLength * _settings.gridSize + TEXT_PADDING, textLength * _settings.gridSize + TEXT_PADDING));
+    }
+
+    // Brush
+    auto sRect = sizeRect();
+    /*
+    if (!instance && scene()->drag) {
+        sRect = newBoundingRect();
+        setSize(sRect.width(), sRect.height());
+        setPos(pos());
     }
-}
+    */
+    if (isHighlighted() && drawConnectionPoint) {
+        // Line pen
+        QPen penLine(Qt::red, 5, Qt::DashLine);
+
+        // Line brush
+        QBrush brushLine;
+        brushLine.setStyle(Qt::NoBrush);
+
+        // Draw the connection line
+        painter->setPen(penLine);
+        painter->setBrush(brushLine);
+        painter->drawLine(sRect.center(), mapFromScene(connectionPoint));
+    }
+
+    // Pen
+    QPen pen;
+    if (isHighlighted()) {
+        pen.setColor(COLOR_HIGHLIGHT_BODY_BORDER);
+        pen.setWidth(PEN_HIGHLIGHT_WIDTH);
+    } else {
+        pen.setColor(COLOR_BODY_BORDER);
+        pen.setWidth(PEN_WIDTH);
+    }
+    pen.setStyle(Qt::SolidLine);
+    painter->setPen(pen);
+    if (isHighlighted()) {
+        painter->drawRect(sRect);
+    }
+    //Draw the component body
+    
+  //  painter->drawRect(sRect);
+    QBrush brush;
+    if (instance) {
+        if (isHighlighted()) {
+            brush.setColor(COLOR_HIGHLIGHT_BODY_FILL);
+        } else {
+            brush.setColor(COLOR_BODY_FILL);
+        }
+        painter->setPen(Qt::white);
+    } else {
+        brush.setColor(QColor("#E0E0E0"));
+        painter->setPen(Qt::black);
+    }
+    brush.setStyle(Qt::SolidPattern);
+    painter->setBrush(brush);
+    auto r = sRect.adjusted(padding, padding, -padding, -padding);
+    painter->drawRect(r);
+    if (moduleName.isEmpty()) {
+        if (instance)
+            drawTextFitToRect(r, name, painter);
+        else {
+            int X = r.center().x() - painter->fontMetrics().horizontalAdvance(name) / 2;
+            int Y = r.bottom() - 5;
+            painter->drawText(X, Y, name);
+        }
+    }
+    else {
+        drawTextFitToRect(QRectF(r.topLeft(), QSizeF(r.width(), r.height() * 0.66)), name, painter);
+        drawTextFitToRect(QRectF(r.topLeft() + QPointF(0, r.height() * 0.66), QSizeF(r.width(), r.height() * 0.33)), moduleName, painter);
+    }
+
+    // Resize handles
+    if (isSelected() && allowMouseResize()) {
+        paintResizeHandles(*painter);
+    }
+
+    // Rotate handle
+    if (isSelected() && allowMouseRotate()) {
+        paintRotateHandle(*painter);
+    }
+}
+
+void IPInstance::contextMenuEvent(QGraphicsSceneContextMenuEvent* event)
+{
+    // Create the menu
+    QMenu menu;
+    {
+        // Align label
+        QAction* alignConnectorLabels = new QAction;
+        alignConnectorLabels->setText("Align connector labels");
+        connect(alignConnectorLabels, &QAction::triggered, [this] {
+            this->alignConnectorLabels();
+            });
+        // Assemble
+        menu.addAction(alignConnectorLabels);
+
+        menu.addSeparator();
+
+        /* QAction* renameInstance = new QAction;
+        renameInstance->setText("Rename Instance");
+        connect(renameInstance, &QAction::triggered, [this] { this->renameInstance(); });
+        menu.addAction(renameInstance);
+
+        QAction* renameModule = new QAction;
+        renameModule->setText("Rename Module");
+        connect(renameModule, &QAction::triggered, [this] { this->renameModule(); });
+        menu.addAction(renameModule); */
+    }
+    // Sow the menu
+    menu.exec(event->screenPos());
+}
+
+void IPInstance::renameModule() {
+    QInputDialog dialog;
+    QString title = "Rename Module \"" + moduleName + "\"";
+    dialog.setWindowTitle(title);
+    dialog.setLabelText(tr("New Name:"));
+    dialog.setWindowFlags(Qt::Window | Qt::WindowCloseButtonHint | Qt::CustomizeWindowHint);
+    int w = 300 + title.length();
+    dialog.resize(QSize(w, 300));
+    dialog.move(QCursor::pos());
+    if (dialog.exec()) {
+        QString text = dialog.textValue();
+        if (text.length() > 0) {
+            moduleName = text;
+        }
+    }
+}
+
+void IPInstance::renameInstance() {
+    QInputDialog dialog;
+    QString title = "Rename Instance \"" + name + "\"";
+    dialog.setWindowTitle(title);
+    dialog.setLabelText(tr("New Name:"));
+    dialog.setWindowFlags(Qt::Window | Qt::WindowCloseButtonHint | Qt::CustomizeWindowHint);
+    int w = 300 + title.length();
+    dialog.resize(QSize(w, 300));
+    dialog.move(QCursor::pos());
+    if (dialog.exec()) {
+        QString text = dialog.textValue();
+        if (text.length() > 0) {
+            name = text;
+        }
+    }
+}
diff --git a/src/sw/noc_dev/IPStudio_qt6/GUI/MainWindow/IPDesign.cpp b/src/sw/noc_dev/IPStudio_qt6/GUI/MainWindow/IPDesign.cpp
index 229d5c1ebec..02e8b1b275e 100644
--- a/src/sw/noc_dev/IPStudio_qt6/GUI/MainWindow/IPDesign.cpp
+++ b/src/sw/noc_dev/IPStudio_qt6/GUI/MainWindow/IPDesign.cpp
@@ -70,6 +70,7 @@ void IPDesign::refresh(const NetSpeed::BDS::Module* module)
     scene->clear();
     instanceConn.clear();
     instanceWires.clear();
+    outIntfConns.clear();
     const double groupFontSize = 40;
     QFont titleFont;
     titleFont.setPointSizeF(groupFontSize);
@@ -80,13 +81,22 @@ void IPDesign::refresh(const NetSpeed::BDS::Module* module)
     const int rotateHandleWidth = 3;
     size_t large = 0;
     QFont font;
+    QRectF covert;
     QFontMetrics metric(font);
     QMap<std::string, IPInstance*> existingInstances;
 
     auto constructInstance = [&](auto instance, auto const& borderPos, int index, bool drawConnectionPoint = false) {
         
         int pinpaddingAtEdges = 2, interfaceLength =2;
-        for (auto const& it : instance->connectivity) {
+        QList<NetSpeed::BDS::IntfConn*> connectivity;
+        if (instance) {
+            for (auto& in : instance->connectivity) {
+                connectivity.push_back(in.get());
+            }
+        }
+        else
+            connectivity = outIntfConns;
+        for (auto const& it : connectivity) {
             pinpaddingAtEdges = std::max(static_cast<int>(std::ceil(metric.tightBoundingRect(""/*it.first.port_name.c_str()*/).width() / _settings.gridSize)), pinpaddingAtEdges);
             // TODO: fix empty string above
             interfaceLength = std::max(static_cast<int>(std::ceil(metric.tightBoundingRect(it->name.c_str()).width() / _settings.gridSize)), interfaceLength);
@@ -109,14 +119,24 @@ void IPDesign::refresh(const NetSpeed::BDS::Module* module)
             return QRectF(QPointF(),
                           QSizeF(borderWidth * _settings.gridSize, borderHeight * _settings.gridSize));
         };
-        auto rect = calculateBorderRect(instance);
+        auto rect = covert;
+        if (instance)
+            rect = calculateBorderRect(instance);
         auto ipInstance = std::make_shared<IPInstance>(instance, borderPadding * _settings.gridSize, rect, drawConnectionPoint);
-        existingInstances[instance->name] = ipInstance.get();
+        if (instance)
+            existingInstances[instance->name] = ipInstance.get();
+        else {
+            ipInstance->setInstanceName(mw->getProjectName());
+        }
         ipInstance->setObject(object);
-        auto pos = borderPos;
-        if(index > 0)  pos += (index % 2) ? QPoint(interfaceLength * _settings.gridSize + TEXT_PADDING, interfaceLength * _settings.gridSize + TEXT_PADDING)
-                                          : QPoint(0, interfaceLength * _settings.gridSize  + TEXT_PADDING);
-        ipInstance->setPos(pos.rx(), pos.ry());
+        if (instance) {
+            auto pos = borderPos;
+            if (index > 0)
+                pos += (index % 2) ? QPoint(interfaceLength * _settings.gridSize + TEXT_PADDING,
+                                            interfaceLength * _settings.gridSize + TEXT_PADDING) :
+                                     QPoint(0, interfaceLength * _settings.gridSize + TEXT_PADDING);
+            ipInstance->setPos(pos.rx(), pos.ry());
+        }
         ipInstance->textLength = interfaceLength;
         auto parentRect = rect.adjusted(borderPadding * _settings.gridSize, borderPadding * _settings.gridSize,
                                        -borderPadding * _settings.gridSize, -borderPadding * _settings.gridSize);
@@ -130,9 +150,14 @@ void IPDesign::refresh(const NetSpeed::BDS::Module* module)
         QPoint startPoint = QPoint(pinpaddingAtEdges + borderPadding, 0);
         const int leftRotateHandle = rect.width() / 2 / _settings.gridSize - 1;
         const int rightRotateHandle = leftRotateHandle + 2;
-        for (auto const& it : instance->connectivity) {
-            auto insConn = std::make_shared<IPConnectivity>(*it, startPoint);
-            instanceConn[instance->name].push_back(insConn.get());
+        bool g = false;
+        if (!instance) g = true;
+        for (auto& it : connectivity) {
+            auto insConn = std::make_shared<IPConnectivity>(*it, startPoint, nullptr, g);
+            if (instance)
+                instanceConn[instance->name].push_back(insConn.get());
+            else
+                instanceConn[mw->getProjectName().toStdString()].push_back(insConn.get());
             ipInstance->addConnector(*it, insConn);
             QRectF pinNameRect, ifceRect;
             if (totalPinDistance < topLimit) {
@@ -255,24 +280,64 @@ void IPDesign::refresh(const NetSpeed::BDS::Module* module)
                                                                         instance->textLength * _settings.gridSize + TEXT_PADDING);
         calculatePos(rect);
     };
-
+    auto createInstanceG = [&](NetSpeed::BDS::Instance* ins) {
+        auto instanceG = constructInstance(ins, currentPos, index);
+        scene->addItem(instanceG);
+        return instanceG;
+    };
     for (auto const& inst : module->instances) {
         if (!existingInstances.contains(inst->name)) {
             createInstance(inst.get());
             /*Build ifces*/
             QList<QString> ifces_name;
             for (auto const& ifce : inst->connectivity) {
+                if ((ifce->mode == Conn_mode::Expose)) {
+                    bool f = false;
+                    for (auto& infc : outIntfConns) {
+                        if (infc->name != ifce->name) continue;
+                        f = true;
+                        break;
+                    }
+                    if (!f) {
+                        outIntfConns.push_back(ifce.get());
+                    }
+                }
                 ifces_name.push_back(QString::fromStdString(ifce->ifce->name));
             }
             ifces.insert(std::pair<const QString, const QList<QString>>(QString::fromStdString(inst->name), ifces_name));           
         }
     }
 
-     /* Build instanceWires */
+    QRectF unitedRect;
+    QVector<QRectF> squares;
     for (auto const& inst : module->instances) {
-        buildInstanceWires(inst.get()); 
+        if (existingInstances.contains(inst->name)) {
+            auto it = existingInstances.value(inst->name);
+            QRectF rectInScene = it->mapToScene(it->boundingRect()).boundingRect();
+            squares.push_back(rectInScene);
+            if (unitedRect.isNull())
+                unitedRect = rectInScene;
+            else
+                unitedRect |= rectInScene;
+        }
     }
-
+    qreal padding = 100.0;
+    covert = unitedRect;
+    covert.adjust(-padding, -padding, padding, padding);
+    /* Creating huge instance */
+    auto instanceG = createInstanceG(nullptr);
+    /*------------------------*/
+    qreal offsetY = (covert.height() - unitedRect.height()) / 2.0;
+    qreal offsetX = (covert.width() - unitedRect.width()) / 2.0;
+    for (auto& inst : existingInstances) {
+        inst->setPos(inst->pos() + QPointF(offsetX, offsetY));
+        inst->setParentItem(instanceG.get());
+    }
+    /* Build instanceWires */
+    for (auto const& inst : module->instances) {
+        buildInstanceWires(inst.get());
+    }
+    /*---------------------*/
     if (wireDialog) {
         wireDialog->refresh(ifces);
     }
@@ -306,7 +371,7 @@ void IPDesign::buildInstanceWires(Instance* inst)
 
         for (const IfceNetEndpt& ifce_net_end_pt : net_con) {
             if (!ifce_net_end_pt.instance)  continue;
-            if (ifce_net_end_pt.instance->name != inst->name) continue;          
+            if (ifce_net_end_pt.instance->name != inst->name) continue;
             if (1 == net_con.size()) {
                 /* Do nothing */
             } else {
@@ -316,8 +381,12 @@ void IPDesign::buildInstanceWires(Instance* inst)
                     if (!ifce_net_end_pt.instance) {
                         /* Do nothing */
                     } else if (ifce_net_end_pt.instance->name != inst->name) {
-                        auto con = findConnectivity(ifce_net_end_pt.instance->name, ifce_net_end_pt.if_pin.ifce->name);
-                        if (con) {
+                        if (auto con = findConnectivity(ifce_net_end_pt.instance->name, ifce_net_end_pt.if_pin.ifce->name)) {
+                            desConn.push_back(con);
+                        }
+                    }
+                    if (ifce_net_end_pt.if_pin.mode == Conn_mode::Expose) {
+                        if (auto con = findConnectivity(mw->getProjectName().toStdString(), ifce_net_end_pt.if_pin.name)) {
                             desConn.push_back(con);
                         }
                     }
@@ -338,7 +407,6 @@ IPConnectivity* IPDesign::findConnectivity(std::string instance_name, std::strin
     if (instance_name.empty() || ifce_name.empty()) {
         return ipconn;
     }
-
     auto conns = instanceConn.value(instance_name);
     /* Looking for instance name */
     for (auto& conn : conns) {
@@ -355,7 +423,6 @@ QPair<QList<std::shared_ptr<Wire>>, QList<IPConnectivity*>> IPDesign::highlightW
 {   
     QList<std::shared_ptr<Wire>> wireList;
     QList<IPConnectivity*> connList;
-    std::unordered_map<IPConnectivity*, IPConnectivity*> wiresRouted;
 
     if (instName.isEmpty()) return qMakePair(wireList, connList);
 
@@ -366,14 +433,12 @@ QPair<QList<std::shared_ptr<Wire>>, QList<IPConnectivity*>> IPDesign::highlightW
                 conn.first->setHighlighted(true);
                 connList.append(conn.first);
                 for (auto const& desConn : conn.second) {
-                    if ((wiresRouted[conn.first] == desConn) || (wiresRouted[desConn] == conn.first)) break;
                     auto wire = constructWire(conn.first, desConn, true);
                     if (wire) {
                         wire->setHighlighted(true);
                         desConn->setHighlighted(true);
                         wireList.append(wire);                           
                         connList.append(desConn);
-                        wiresRouted[conn.first] = desConn;
                     }
                 }
                 break;
@@ -474,6 +539,12 @@ void IPDesign::showWires()
     }
 }
 
+void IPDesign::refreshWires()
+{
+    if (!wireDialog || wireDialog->getCheckedValues().isEmpty()) return;
+    renderWires(wireDialog->getCheckedValues(), wireDialog->isSmartRouting());
+}
+
 bool IPDesign::event(QEvent* event)
 {
     auto events = { QEvent::GraphicsSceneMouseMove,  QEvent::GraphicsSceneMousePress,
@@ -537,6 +608,7 @@ Avoid::ConnRef * IPDesign::computeWire(IPConnectivity * start, IPConnectivity *
 std::shared_ptr<Wire> IPDesign::constructWire(IPConnectivity* start, IPConnectivity* end, bool highlight)
 {
     bool swap = false;
+    bool expose = false;
 
     if (!highlight) {
         if ((wiresRouted[start] == end) || (wiresRouted[end] == start)) {
@@ -546,6 +618,7 @@ std::shared_ptr<Wire> IPDesign::constructWire(IPConnectivity* start, IPConnectiv
     } else if (wiresRouted[end] == start) {
         swap = true;
     }
+    if (end->getInstanceName() == mw->getProjectName()) expose = true;
 
     IPConnectivity* ptrSrc = start;
     IPConnectivity* ptrDes = end;
@@ -564,15 +637,72 @@ std::shared_ptr<Wire> IPDesign::constructWire(IPConnectivity* start, IPConnectiv
     auto src = ptrSrc->getConnectingScenePos();
     auto des = ptrDes->getConnectingScenePos();
 
-    int offset = 100;
-    int wirePadding = 50;
+    if (expose) {
+        switch (ptrDes->dir) {
+            case TOP:
+                des = des + QPointF(-_settings.gridSize, _settings.gridSize * 5);
+                break;
+            case RIGHT:
+                des = des + QPointF(-_settings.gridSize * 5, -_settings.gridSize);
+                break;
+            case BOTTOM:
+                des = des + QPointF(-_settings.gridSize, -_settings.gridSize * 5);
+                break;
+            case LEFT:
+                des = des + QPointF(_settings.gridSize * 5, -_settings.gridSize);
+                break;
+        }
+    }
+
+    QPointF subSrcInstanceTopLeft, subSrcInstanceTopRight, subSrcInstanceBottomRight, hugeInstanceTopLeft, hugeInstanceBottomRight;
+    if (auto subInstance = ptrSrc->parentItem()) {
+        subSrcInstanceTopLeft  = subInstance->sceneBoundingRect().topLeft();
+        subSrcInstanceTopRight = subInstance->sceneBoundingRect().topRight();
+        subSrcInstanceBottomRight = subInstance->sceneBoundingRect().bottomRight();
+        if (auto hugeInstance = subInstance->parentItem()) {
+            if (hugeInstance->isSelected()) hugeInstance->setSelected(false);
+            hugeInstanceTopLeft = hugeInstance->sceneBoundingRect().topLeft();
+            hugeInstanceBottomRight = hugeInstance->sceneBoundingRect().bottomRight();
+        }
+    }
+
+    QPointF subDesInstanceTopLeft, subDesInstanceBottomRight;
+    if (auto subInstance = ptrDes->parentItem()) {
+        subDesInstanceTopLeft  = subInstance->sceneBoundingRect().topLeft();
+        subDesInstanceBottomRight = subInstance->sceneBoundingRect().bottomRight();
+    }
+
+    int srcHorizontalPadding = 0, desHorizontalPadding = 0, srcVeticalPadding = 0, desVerticalPadding = 0, horizontalOffset = 0;
+    int wirePadding = 20;
+    int hugeIntancePadding = 3;
+    auto topOffset = subSrcInstanceTopLeft.y() - hugeInstanceTopLeft.y() - hugeIntancePadding;
+    auto bottomOffset = hugeInstanceBottomRight.y() - subSrcInstanceBottomRight.y() - hugeIntancePadding;
+    
+
+    if ((ptrSrc->dir == RIGHT) || (ptrSrc->dir == LEFT)) {
+        int indexOfPin = (src.ry() - subSrcInstanceTopLeft.y()) / 20;
+        srcHorizontalPadding = indexOfPin * _settings.gridSize;
+    }
+    if ((ptrSrc->dir == TOP) || (ptrSrc->dir == BOTTOM)) {
+        int indexOfPin = (src.rx() - subSrcInstanceTopLeft.x()) / 20;
+        srcVeticalPadding = indexOfPin * _settings.gridSize;
+    }
+    if ((ptrDes->dir == RIGHT) || (ptrDes->dir == LEFT)) {
+        int indexOfPin = (des.ry() - subDesInstanceTopLeft.y()) / 20;
+        desHorizontalPadding = indexOfPin * _settings.gridSize;
+    }
+    if ((ptrDes->dir == TOP) || (ptrDes->dir == BOTTOM)) {
+        int indexOfPin = (des.rx() - subDesInstanceTopLeft.x()) / 20;
+        desVerticalPadding = indexOfPin * _settings.gridSize;
+        horizontalOffset = subDesInstanceTopLeft.x() - subSrcInstanceTopRight.x();
+    }
 
     wire->append_point(_settings.snapToGrid(src));
     /* Config wires direction */
     switch (ptrSrc->dir) {
         case TOP:
             /* Config source wires direction */
-            temp = QPointF(src.rx(), src.ry() - wirePadding);
+            temp = QPointF(src.rx(), src.ry() - wirePadding - srcVeticalPadding);
             pre_temp = temp;
             wire->append_point(_settings.snapToGrid(temp)); /* Draw up */
             
@@ -583,7 +713,7 @@ std::shared_ptr<Wire> IPDesign::constructWire(IPConnectivity* start, IPConnectiv
                     wire->append_point(_settings.snapToGrid(temp)); /* Draw horizontal */
                     break;
                 case RIGHT:
-                    temp = QPointF(des.rx() + wirePadding, pre_temp.y());
+                    temp = QPointF(des.rx() + wirePadding + desHorizontalPadding, pre_temp.y());
                     pre_temp = temp;
                     wire->append_point(_settings.snapToGrid(temp)); /* Draw horizontal */
 
@@ -591,11 +721,13 @@ std::shared_ptr<Wire> IPDesign::constructWire(IPConnectivity* start, IPConnectiv
                     wire->append_point(_settings.snapToGrid(temp)); /* Draw vertical */
                     break;
                 case BOTTOM:
-                    temp = QPointF(pre_temp.x() + offset, pre_temp.y());
+                    if (expose) temp = QPointF(pre_temp.x() - (subSrcInstanceTopLeft.x() - hugeInstanceTopLeft.x()), pre_temp.y());
+                    else temp = QPointF(pre_temp.x() + horizontalOffset, pre_temp.y());
                     pre_temp = temp;
                     wire->append_point(_settings.snapToGrid(temp)); /* Draw horizontal */
 
-                    temp = QPointF(pre_temp.x(), des.ry() + wirePadding);
+                    if (expose) temp = QPointF(pre_temp.x(), des.ry());
+                    else temp = QPointF(pre_temp.x(), des.ry() + wirePadding + desVerticalPadding);
                     pre_temp = temp;
                     wire->append_point(_settings.snapToGrid(temp)); /* Draw vertical */
 
@@ -603,7 +735,8 @@ std::shared_ptr<Wire> IPDesign::constructWire(IPConnectivity* start, IPConnectiv
                     wire->append_point(_settings.snapToGrid(temp)); /* Draw horizontal */
                     break;
                 case LEFT:
-                    temp = QPointF(des.rx() - wirePadding, pre_temp.y());
+                    if (expose) temp = QPointF(des.rx() + wirePadding, pre_temp.y());
+                    else temp = QPointF(des.rx() - wirePadding - desHorizontalPadding, pre_temp.y());
                     pre_temp = temp;
                     wire->append_point(_settings.snapToGrid(temp)); /* Draw horizontal */
 
@@ -615,34 +748,42 @@ std::shared_ptr<Wire> IPDesign::constructWire(IPConnectivity* start, IPConnectiv
             }
             break;
         case RIGHT:
-            temp = QPointF(src.rx() + wirePadding, src.ry());
+            temp = QPointF(src.rx() + wirePadding + srcHorizontalPadding, src.ry());
             pre_temp = temp;
             wire->append_point(_settings.snapToGrid(temp)); /* Draw horizontally to the right */
 
             /* Config destination wires direction */
             switch (ptrDes->dir) {
                 case TOP:
-                    temp = QPointF(pre_temp.x(), pre_temp.y() - offset * 2);
+                    if (expose) temp = QPointF(pre_temp.x(), pre_temp.y() - topOffset);
+                    else temp = QPointF(pre_temp.x(), des.ry() - wirePadding - desVerticalPadding);
                     pre_temp = temp;
                     wire->append_point(_settings.snapToGrid(temp)); /* Draw vertical */
 
-                    temp = QPointF(des.x(), pre_temp.y());
+                    temp = QPointF(des.rx(), pre_temp.y());
                     wire->append_point(_settings.snapToGrid(temp)); /* Draw horizontal */
                     break;
                 case RIGHT:
-                    temp = QPointF(pre_temp.x(), pre_temp.y() - offset * 2);
-                    pre_temp = temp;
-                    wire->append_point(_settings.snapToGrid(temp)); /* Draw vertical */
-
-                    temp = QPointF(des.rx() + wirePadding, pre_temp.y());
-                    pre_temp = temp;
-                    wire->append_point(_settings.snapToGrid(temp)); /* Draw horizontal */
-
-                    temp = QPointF(pre_temp.x(), des.y());
-                    wire->append_point(_settings.snapToGrid(temp));  /* Draw vertical */
-                    break;
+                    if (expose) {
+                        temp = QPointF(pre_temp.x(), des.ry());
+                        wire->append_point(_settings.snapToGrid(temp)); /* Draw vertical */
+                        break;
+                    } else {
+                        temp = QPointF(pre_temp.x(), pre_temp.y() - topOffset);
+                        pre_temp = temp;
+                        wire->append_point(_settings.snapToGrid(temp)); /* Draw vertical */
+
+                        temp = QPointF(des.rx() + wirePadding + desHorizontalPadding, pre_temp.y());
+                        pre_temp = temp;
+                        wire->append_point(_settings.snapToGrid(temp)); /* Draw horizontal */
+
+                        temp = QPointF(pre_temp.x(), des.ry());
+                        wire->append_point(_settings.snapToGrid(temp));  /* Draw vertical */
+                        break;
+                    }
                 case BOTTOM:
-                    temp = QPointF(pre_temp.x(), pre_temp.y() + offset * 2);
+                    if (expose) temp = QPointF(pre_temp.x(), pre_temp.y() + bottomOffset);
+                    else temp = QPointF(pre_temp.x(), des.ry() + wirePadding + desVerticalPadding);
                     pre_temp = temp;
                     wire->append_point(_settings.snapToGrid(temp)); /* Draw vertical */
 
@@ -650,15 +791,7 @@ std::shared_ptr<Wire> IPDesign::constructWire(IPConnectivity* start, IPConnectiv
                     wire->append_point(_settings.snapToGrid(temp)); /* Draw horizontal */
                     break;
                 case LEFT:
-                    temp = QPointF(pre_temp.x(), pre_temp.y() - offset * 2);
-                    pre_temp = temp;
-                    wire->append_point(_settings.snapToGrid(temp)); /* Draw vertical */
-
-                    temp = QPointF(des.rx() - wirePadding, pre_temp.y());
-                    pre_temp = temp;
-                    wire->append_point(_settings.snapToGrid(temp)); /* Draw horizontal */
-
-                    temp = QPointF(pre_temp.x(), des.y());
+                    temp = QPointF(pre_temp.x(), des.ry());
                     wire->append_point(_settings.snapToGrid(temp)); /* Draw vertical */
                     break;
                 default:
@@ -666,18 +799,20 @@ std::shared_ptr<Wire> IPDesign::constructWire(IPConnectivity* start, IPConnectiv
             }
             break;
         case BOTTOM:
-            temp = QPointF(src.rx(), src.ry() + wirePadding);
+            temp = QPointF(src.rx(), src.ry() + wirePadding + srcVeticalPadding);
             pre_temp = temp;
             wire->append_point(_settings.snapToGrid(temp)); /* Draw down */
 
             /* Config destination wires direction */
             switch (ptrDes->dir) {
                 case TOP:
-                    temp = QPointF(pre_temp.x() + offset, pre_temp.y());
+                    if (expose) temp = QPointF(pre_temp.x() - (subSrcInstanceTopLeft.x() - hugeInstanceTopLeft.x()), pre_temp.y());
+                    else temp = QPointF(pre_temp.x() + horizontalOffset, pre_temp.y());
                     pre_temp = temp;
                     wire->append_point(_settings.snapToGrid(temp)); /* Draw horizontal */
 
-                    temp = QPointF(pre_temp.x(), des.ry() - wirePadding);
+                    if (expose) temp = QPointF(pre_temp.x(), des.ry());
+                    else temp = QPointF(pre_temp.x(), des.ry() - wirePadding - desVerticalPadding);
                     pre_temp = temp;
                     wire->append_point(_settings.snapToGrid(temp)); /* Draw vertical */
 
@@ -685,7 +820,7 @@ std::shared_ptr<Wire> IPDesign::constructWire(IPConnectivity* start, IPConnectiv
                     wire->append_point(_settings.snapToGrid(temp)); /* Draw horizontal */
                     break;
                 case RIGHT:
-                    temp = QPointF(des.rx() + wirePadding, pre_temp.y());
+                    temp = QPointF(des.rx() + wirePadding + desHorizontalPadding, pre_temp.y());
                     pre_temp = temp;
                     wire->append_point(_settings.snapToGrid(temp)); /* Draw horizontal */
 
@@ -697,7 +832,7 @@ std::shared_ptr<Wire> IPDesign::constructWire(IPConnectivity* start, IPConnectiv
                     wire->append_point(_settings.snapToGrid(temp)); /* Draw horizontal */
                     break;
                 case LEFT:
-                    temp = QPointF(des.rx() - wirePadding, pre_temp.y());
+                    temp = QPointF(des.rx() - wirePadding - desHorizontalPadding, pre_temp.y());
                     pre_temp = temp;
                     wire->append_point(_settings.snapToGrid(temp)); /* Draw horizontal */
 
@@ -709,14 +844,15 @@ std::shared_ptr<Wire> IPDesign::constructWire(IPConnectivity* start, IPConnectiv
             }
             break;
         case LEFT:
-            temp = QPointF(src.rx() - wirePadding, src.ry());
+            temp = QPointF(src.rx() - wirePadding - srcHorizontalPadding, src.ry());
             pre_temp = temp;
             wire->append_point(_settings.snapToGrid(temp)); /* Draw horizontally to the left */
 
             /* Config destination wires direction */
             switch (ptrDes->dir) {
                 case TOP:
-                    temp = QPointF(pre_temp.x(), pre_temp.y() - offset * 2);
+                    if (expose) temp = QPointF(pre_temp.x(), pre_temp.y() - topOffset);
+                    else temp = QPointF(pre_temp.x(), des.ry() - wirePadding - desVerticalPadding);
                     pre_temp = temp;
                     wire->append_point(_settings.snapToGrid(temp)); /* Draw vertical */
 
@@ -724,15 +860,12 @@ std::shared_ptr<Wire> IPDesign::constructWire(IPConnectivity* start, IPConnectiv
                     wire->append_point(_settings.snapToGrid(temp)); /* Draw horizontal */
                     break;
                 case RIGHT:
-                    temp = QPointF(pre_temp.x(), pre_temp.y() - offset * 2);
-                    pre_temp = temp;
+                    temp = QPointF(pre_temp.x(), des.ry());
                     wire->append_point(_settings.snapToGrid(temp)); /* Draw vertical */
-
-                    temp = QPointF(des.rx() + wirePadding, pre_temp.y());
-                    wire->append_point(_settings.snapToGrid(temp)); /* Draw horizontal */
                     break;
                 case BOTTOM:
-                    temp = QPointF(pre_temp.x(), pre_temp.y() + offset * 2);
+                    if (expose) temp = QPointF(pre_temp.x(), pre_temp.y() + bottomOffset);
+                    else temp = QPointF(pre_temp.x(), des.ry() + wirePadding + desVerticalPadding);
                     pre_temp = temp;
                     wire->append_point(_settings.snapToGrid(temp)); /* Draw vertical */
 
@@ -740,17 +873,23 @@ std::shared_ptr<Wire> IPDesign::constructWire(IPConnectivity* start, IPConnectiv
                     wire->append_point(_settings.snapToGrid(temp)); /* Draw horizontal */
                     break;
                 case LEFT:
-                    temp = QPointF(pre_temp.x(), pre_temp.y() - offset * 2);
-                    pre_temp = temp;
-                    wire->append_point(_settings.snapToGrid(temp)); /* Draw vertical */
-
-                    temp = QPointF(des.rx() - wirePadding, pre_temp.y());
-                    pre_temp = temp;
-                    wire->append_point(_settings.snapToGrid(temp)); /* Draw horizontal */
-
-                    temp = QPointF(pre_temp.x(), des.ry());
-                    wire->append_point(_settings.snapToGrid(temp)); /* Draw vertical */
-                    break;
+                    if (expose) {
+                        temp = QPointF(pre_temp.x(), des.ry());
+                        wire->append_point(_settings.snapToGrid(temp)); /* Draw vertical */
+                        break;
+                    } else {
+                        temp = QPointF(pre_temp.x(), pre_temp.y() - topOffset);
+                        pre_temp = temp;
+                        wire->append_point(_settings.snapToGrid(temp)); /* Draw vertical */
+
+                        temp = QPointF(des.rx() - wirePadding - desHorizontalPadding, pre_temp.y());
+                        pre_temp = temp;
+                        wire->append_point(_settings.snapToGrid(temp)); /* Draw horizontal */
+
+                        temp = QPointF(pre_temp.x(), des.ry());
+                        wire->append_point(_settings.snapToGrid(temp)); /* Draw vertical */
+                        break;
+                    }
                 default:
                     break;
             }
@@ -758,7 +897,6 @@ std::shared_ptr<Wire> IPDesign::constructWire(IPConnectivity* start, IPConnectiv
         default:
             break;
     }
-    
     wire->append_point(_settings.snapToGrid(des));
     attachWireToConnector(wire, static_cast<IPInstance*>(ptrDes->parentItem()), ptrDes->scenePos());
     completeWire(wire);
diff --git a/src/sw/noc_dev/IPStudio_qt6/GUI/MainWindow/IPDialog.cpp b/src/sw/noc_dev/IPStudio_qt6/GUI/MainWindow/IPDialog.cpp
index 496f00ff344..80813981968 100644
--- a/src/sw/noc_dev/IPStudio_qt6/GUI/MainWindow/IPDialog.cpp
+++ b/src/sw/noc_dev/IPStudio_qt6/GUI/MainWindow/IPDialog.cpp
@@ -276,7 +276,6 @@ const QMap<QString, QList<QString>> ShowWiresDialog::getCheckedValues() const
     return map;
 }
 
-
 bool ShowWiresDialog::isSmartRouting() const
 {
     return smartRouting->isChecked();
diff --git a/src/sw/noc_dev/IPStudio_qt6/GUI/WireItem/item.cpp b/src/sw/noc_dev/IPStudio_qt6/GUI/WireItem/item.cpp
index f1630a9af26..b643529b194 100644
--- a/src/sw/noc_dev/IPStudio_qt6/GUI/WireItem/item.cpp
+++ b/src/sw/noc_dev/IPStudio_qt6/GUI/WireItem/item.cpp
@@ -1,371 +1,374 @@
-#include <QPainter>
-#include <QVector2D>
-#include <QGraphicsSceneHoverEvent>
-#include <QWidget>
-#include "item.h"
-#include "scene.h"
-#include "commanditemmove.h"
-
-using namespace QSchematic;
-
-
-Item::Item(int type, QGraphicsItem* parent) :
-    QGraphicsObject(parent),
-    _type(type),
-    _snapToGrid(true),
-    _highlightEnabled(true),
-    _highlighted(false),
-    _oldRot{0}
-{
-    // Misc
-    setAcceptHoverEvents(true);
-    setFlag(QGraphicsItem::ItemSendsGeometryChanges, true);
-    setFlag(QGraphicsItem::ItemIsSelectable, true);
-    setFlag(QGraphicsItem::ItemIsMovable, true);
-    connect(this, &Item::xChanged, this, &Item::posChanged);
-    connect(this, &Item::yChanged, this, &Item::posChanged);
-    connect(this, &Item::rotationChanged, this, &Item::rotChanged);
-
-    // Connect signals to parent item
-    Item* parentItem = static_cast<Item*>(parent);
-    if (parentItem) {
-        connect(parentItem, &Item::moved, this, &Item::scenePosChanged);
-        connect(parentItem, &Item::rotated, this, &Item::scenePosChanged);
-    }
-}
-
-Item::~Item()
-{
-    // Important insurance — if this is NOT expired, then we've been deleted
-    // wrongly by Qt and all kinds of dirty shit will hit the fan!
-    // Q_ASSERT(SharedPtrTracker::assert_expired(this));
-    //Q_ASSERT(weakPtr().expired());
-}
-
-void Item::copyAttributes(Item& dest) const
-{
-    // Base class
-    dest.setParentItem(parentItem());
-    dest.setPos(pos());
-    dest.setRotation(rotation());
-    dest.setVisible(isVisible());
-
-    // Attributes
-    dest._snapToGrid = _snapToGrid;
-    dest._highlightEnabled = _highlightEnabled;
-    dest._highlighted = _highlighted;
-    dest._oldPos = _oldPos;
-    dest._oldRot = _oldRot;
-}
-
-Scene* Item::scene() const
-{
-    return qobject_cast<Scene*>(QGraphicsObject::scene());
-}
-
-int Item::type() const
-{
-    return _type;
-}
-
-void Item::setGridPos(const QPoint& gridPos)
-{
-    setPos(_settings.toScenePoint(gridPos));
-}
-
-void Item::setGridPos(int x, int y)
-{
-    setGridPos(QPoint(x, y));
-}
-
-void Item::setGridPosX(int x)
-{
-    setGridPos(x, gridPosY());
-}
-
-void Item::setGridPosY(int y)
-{
-    setGridPos(gridPosX(), y);
-}
-
-QPoint Item::gridPos() const
-{
-    return _settings.toGridPoint(pos().toPoint());
+#include <QPainter>
+#include <QVector2D>
+#include <QGraphicsSceneHoverEvent>
+#include <QWidget>
+#include "item.h"
+#include "scene.h"
+#include "commanditemmove.h"
+#include "../../include/IPInstance.h"
+
+using namespace QSchematic;
+
+
+Item::Item(int type, QGraphicsItem* parent) :
+    QGraphicsObject(parent),
+    _type(type),
+    _snapToGrid(true),
+    _highlightEnabled(true),
+    _highlighted(false),
+    _oldRot{0}
+{
+    // Misc
+    setAcceptHoverEvents(true);
+    setFlag(QGraphicsItem::ItemSendsGeometryChanges, true);
+    setFlag(QGraphicsItem::ItemIsSelectable, true);
+    setFlag(QGraphicsItem::ItemIsMovable, true);
+    connect(this, &Item::xChanged, this, &Item::posChanged);
+    connect(this, &Item::yChanged, this, &Item::posChanged);
+    connect(this, &Item::rotationChanged, this, &Item::rotChanged);
+
+    // Connect signals to parent item
+    Item* parentItem = static_cast<Item*>(parent);
+    if (parentItem) {
+        connect(parentItem, &Item::moved, this, &Item::scenePosChanged);
+        connect(parentItem, &Item::rotated, this, &Item::scenePosChanged);
+    }
+}
+
+Item::~Item()
+{
+    // Important insurance — if this is NOT expired, then we've been deleted
+    // wrongly by Qt and all kinds of dirty shit will hit the fan!
+    // Q_ASSERT(SharedPtrTracker::assert_expired(this));
+    //Q_ASSERT(weakPtr().expired());
+}
+
+void Item::copyAttributes(Item& dest) const
+{
+    // Base class
+    dest.setParentItem(parentItem());
+    dest.setPos(pos());
+    dest.setRotation(rotation());
+    dest.setVisible(isVisible());
+
+    // Attributes
+    dest._snapToGrid = _snapToGrid;
+    dest._highlightEnabled = _highlightEnabled;
+    dest._highlighted = _highlighted;
+    dest._oldPos = _oldPos;
+    dest._oldRot = _oldRot;
+}
+
+Scene* Item::scene() const
+{
+    return qobject_cast<Scene*>(QGraphicsObject::scene());
+}
+
+int Item::type() const
+{
+    return _type;
+}
+
+void Item::setGridPos(const QPoint& gridPos)
+{
+    setPos(_settings.toScenePoint(gridPos));
+}
+
+void Item::setGridPos(int x, int y)
+{
+    setGridPos(QPoint(x, y));
+}
+
+void Item::setGridPosX(int x)
+{
+    setGridPos(x, gridPosY());
+}
+
+void Item::setGridPosY(int y)
+{
+    setGridPos(gridPosX(), y);
+}
+
+QPoint Item::gridPos() const
+{
+    return _settings.toGridPoint(pos().toPoint());
 }
 
 QRectF QSchematic::Item::gridRectF() const
 {
     return QRectF(gridPos(), boundingRect().size());
-}
-
-int Item::gridPosX() const
-{
-    return gridPos().x();
-}
-
-int Item::gridPosY() const
-{
-    return gridPos().y();
-}
-
-void Item::setPos(const QPointF& pos)
-{
-    QGraphicsObject::setPos(pos);
-}
-
-void Item::setPos(qreal x, qreal y)
-{
-    QGraphicsObject::setPos(x, y);
-}
-
-void Item::setPosX(qreal x)
-{
-    setPos(x, posY());
-}
-
-void Item::setPosY(qreal y)
-{
-    setPos(posX(), y);
-}
-
-QPointF Item::pos() const
-{
-    return QGraphicsObject::pos();
-}
-
-qreal Item::posX() const
-{
-    return pos().x();
-}
-
-qreal Item::posY() const
-{
-    return pos().y();
-}
-
-void Item::setScenePos(const QPointF& point)
-{
-    QGraphicsObject::setPos(mapToParent(mapFromScene(point)));
-}
-
-void Item::setScenePos(qreal x, qreal y)
-{
-    setScenePos(QPointF(x, y));
-}
-
-void Item::setScenePosX(qreal x)
-{
-    setScenePos(x, scenePosY());
-}
-
-void Item::setScenePosY(qreal y)
-{
-    setScenePos(scenePosX(), y);
-}
-
-QPointF Item::scenePos() const
-{
-    return QGraphicsObject::scenePos();
-}
-
-qreal Item::scenePosX() const
-{
-    return scenePos().x();
-}
-
-qreal Item::scenePosY() const
-{
-    return scenePos().y();
-}
-
-void Item::moveBy(const QVector2D& moveBy)
-{
-    setPos(pos() + moveBy.toPointF());
-}
-
-void Item::setSettings(const Settings& settings)
-{
-    // Resnap to grid
-    if (snapToGrid()) {
-        setPos(_settings.snapToGrid(pos()));
-    }
-
-    // Store the new settings
-    _settings = settings;
-
-    // Let everyone know
-    emit settingsChanged();
-
-    // Update
-    update();
-}
-
-const Settings& Item::settings() const
-{
-    return _settings;
-}
-
-void Item::setMovable(bool enabled)
-{
-    setFlag(QGraphicsItem::ItemIsMovable, enabled);
-}
-
-bool Item::isMovable() const
-{
-    return flags() & QGraphicsItem::ItemIsMovable;
-}
-
-void Item::setSnapToGrid(bool enabled)
-{
-    _snapToGrid = enabled;
-}
-
-bool Item::snapToGrid() const
-{
-    return _snapToGrid;
-}
-
-bool Item::isHighlighted() const
-{
-    return ( ( _highlighted || isSelected() ) && _highlightEnabled );
-}
-
-void Item::setHighlighted(bool highlighted)
-{
-    _highlighted = highlighted;
-
-    // Ripple through children
-    for (QGraphicsItem* child : childItems()) {
-        Item* childItem = qgraphicsitem_cast<Item*>(child);
-        if (childItem) {
-            childItem->setHighlighted(highlighted);
-        }
-    }
-}
-
-void Item::setHighlightEnabled(bool enabled)
-{
-    _highlightEnabled = enabled;
-    _highlighted = false;
-}
-
-bool Item::highlightEnabled() const
-{
-    return _highlightEnabled;
-}
-
-QPixmap Item::toPixmap(QPointF& hotSpot, qreal scale)
-{
-    // Retrieve the bounding rect
-    QRectF rectF = boundingRect();
-    rectF = rectF.united(childrenBoundingRect());
-
-    // Adjust the rectangle as the QPixmap doesn't handle negative coordinates
-    rectF.setWidth(rectF.width() - rectF.x());
-    rectF.setHeight(rectF.height() - rectF.y());
-    const QRect& rect = rectF.toRect();
-    if (rect.isNull() || !rect.isValid()) {
-        return QPixmap();
-    }
-
-    // Provide the hot spot
-    hotSpot = -rectF.topLeft();
-
-    // Create the pixmap
-    QPixmap pixmap(rect.size() * scale);
-    pixmap.fill(Qt::transparent);
-
-    // Render
-    QPainter painter(&pixmap);
-    painter.setRenderHint(QPainter::Antialiasing, _settings.antialiasing);
-    painter.setRenderHint(QPainter::TextAntialiasing, _settings.antialiasing);
-    painter.scale(scale, scale);
-    painter.translate(hotSpot);
-    paint(&painter, nullptr, nullptr);
-    for (QGraphicsItem* child : childItems()) {
-        painter.save();
-        painter.translate(child->pos());
-        child->paint(&painter, nullptr, nullptr);
-        painter.restore();
-    }
-
-    painter.end();
-
-    return pixmap;
-}
-
-QVariant Item::itemChange(QGraphicsItem::GraphicsItemChange change, const QVariant& value)
-{
-    switch (change)
-    {
-    case QGraphicsItem::ItemSceneChange:
-    {
-        // NOTE: by doing this non-updated scene (ghost images staying) disappeared for some further cases (tips from usenet)
-        prepareGeometryChange();
-        return QGraphicsItem::itemChange(change, value);
-    }
-    case QGraphicsItem::ItemPositionChange:
-    {
-        QPointF newPos = value.toPointF();
-        if (snapToGrid()) {
-            newPos =_settings.snapToGrid(newPos);
-        }
-        return newPos;
-    }
-    case QGraphicsItem::ItemParentChange:
-        if (parentObject()) {
-            disconnect(parentObject(), nullptr, this, nullptr);
-        }
-        return value;
-    case QGraphicsItem::ItemParentHasChanged:
-    {
-        Item* parent = static_cast<Item*>(parentItem());
-        if (parent) {
-            connect(parent, &Item::moved, this, &Item::scenePosChanged);
-            connect(parent, &Item::rotated, this, &Item::scenePosChanged);
-        }
-        return value;
-    }
-
-    default:
-        return QGraphicsItem::itemChange(change, value);
-    }
-}
-
-void Item::posChanged()
-{
-    scenePosChanged();
-    const QPointF& newPos = pos();
-    QVector2D movedBy(newPos - _oldPos);
-    if (!movedBy.isNull()) {
-        emit moved(*this, movedBy);
-    }
-
-    _oldPos = newPos;
-}
-
-void Item::scenePosChanged()
-{
-    emit movedInScene(*this);
-}
-
-void Item::rotChanged()
-{
-    const qreal newRot = rotation();
-    qreal rotationChange = newRot - _oldRot;
-    if (!qFuzzyIsNull(rotationChange)) {
-        emit rotated(*this, rotationChange);
-    }
-
-    _oldRot = newRot;
-}
-
-void Item::update()
-{
-    // All transformations happen around the center of the item
-    setTransformOriginPoint(boundingRect().width()/2, boundingRect().height()/2);
-
-    // Base class
-    QGraphicsObject::update();
-}
-
+}
+
+int Item::gridPosX() const
+{
+    return gridPos().x();
+}
+
+int Item::gridPosY() const
+{
+    return gridPos().y();
+}
+
+void Item::setPos(const QPointF& pos)
+{
+    QGraphicsObject::setPos(pos);
+}
+
+void Item::setPos(qreal x, qreal y)
+{
+    QGraphicsObject::setPos(x, y);
+}
+
+void Item::setPosX(qreal x)
+{
+    setPos(x, posY());
+}
+
+void Item::setPosY(qreal y)
+{
+    setPos(posX(), y);
+}
+
+QPointF Item::pos() const
+{
+    return QGraphicsObject::pos();
+}
+
+qreal Item::posX() const
+{
+    return pos().x();
+}
+
+qreal Item::posY() const
+{
+    return pos().y();
+}
+
+void Item::setScenePos(const QPointF& point)
+{
+    QGraphicsObject::setPos(mapToParent(mapFromScene(point)));
+}
+
+void Item::setScenePos(qreal x, qreal y)
+{
+    setScenePos(QPointF(x, y));
+}
+
+void Item::setScenePosX(qreal x)
+{
+    setScenePos(x, scenePosY());
+}
+
+void Item::setScenePosY(qreal y)
+{
+    setScenePos(scenePosX(), y);
+}
+
+QPointF Item::scenePos() const
+{
+    return QGraphicsObject::scenePos();
+}
+
+qreal Item::scenePosX() const
+{
+    return scenePos().x();
+}
+
+qreal Item::scenePosY() const
+{
+    return scenePos().y();
+}
+
+void Item::moveBy(const QVector2D& moveBy)
+{
+    setPos(pos() + moveBy.toPointF());
+}
+
+void Item::setSettings(const Settings& settings)
+{
+    // Resnap to grid
+    if (snapToGrid()) {
+        setPos(_settings.snapToGrid(pos()));
+    }
+
+    // Store the new settings
+    _settings = settings;
+
+    // Let everyone know
+    emit settingsChanged();
+
+    // Update
+    update();
+}
+
+const Settings& Item::settings() const
+{
+    return _settings;
+}
+
+void Item::setMovable(bool enabled)
+{
+    setFlag(QGraphicsItem::ItemIsMovable, enabled);
+}
+
+bool Item::isMovable() const
+{
+    return flags() & QGraphicsItem::ItemIsMovable;
+}
+
+void Item::setSnapToGrid(bool enabled)
+{
+    _snapToGrid = enabled;
+}
+
+bool Item::snapToGrid() const
+{
+    return _snapToGrid;
+}
+
+bool Item::isHighlighted() const
+{
+    return ( ( _highlighted || isSelected() ) && _highlightEnabled );
+}
+
+void Item::setHighlighted(bool highlighted)
+{
+    _highlighted = highlighted;
+    auto ins     = dynamic_cast<IPInstance*>(this);
+    if (ins && ins->getInstance()) {
+        // Ripple through children
+        for (QGraphicsItem* child : childItems()) {
+            Item* childItem = qgraphicsitem_cast<Item*>(child);
+            if (childItem) {
+                childItem->setHighlighted(highlighted);
+            }
+        }
+    }
+}
+
+void Item::setHighlightEnabled(bool enabled)
+{
+    _highlightEnabled = enabled;
+    _highlighted = false;
+}
+
+bool Item::highlightEnabled() const
+{
+    return _highlightEnabled;
+}
+
+QPixmap Item::toPixmap(QPointF& hotSpot, qreal scale)
+{
+    // Retrieve the bounding rect
+    QRectF rectF = boundingRect();
+    rectF = rectF.united(childrenBoundingRect());
+
+    // Adjust the rectangle as the QPixmap doesn't handle negative coordinates
+    rectF.setWidth(rectF.width() - rectF.x());
+    rectF.setHeight(rectF.height() - rectF.y());
+    const QRect& rect = rectF.toRect();
+    if (rect.isNull() || !rect.isValid()) {
+        return QPixmap();
+    }
+
+    // Provide the hot spot
+    hotSpot = -rectF.topLeft();
+
+    // Create the pixmap
+    QPixmap pixmap(rect.size() * scale);
+    pixmap.fill(Qt::transparent);
+
+    // Render
+    QPainter painter(&pixmap);
+    painter.setRenderHint(QPainter::Antialiasing, _settings.antialiasing);
+    painter.setRenderHint(QPainter::TextAntialiasing, _settings.antialiasing);
+    painter.scale(scale, scale);
+    painter.translate(hotSpot);
+    paint(&painter, nullptr, nullptr);
+    for (QGraphicsItem* child : childItems()) {
+        painter.save();
+        painter.translate(child->pos());
+        child->paint(&painter, nullptr, nullptr);
+        painter.restore();
+    }
+
+    painter.end();
+
+    return pixmap;
+}
+
+QVariant Item::itemChange(QGraphicsItem::GraphicsItemChange change, const QVariant& value)
+{
+    switch (change)
+    {
+    case QGraphicsItem::ItemSceneChange:
+    {
+        // NOTE: by doing this non-updated scene (ghost images staying) disappeared for some further cases (tips from usenet)
+        prepareGeometryChange();
+        return QGraphicsItem::itemChange(change, value);
+    }
+    case QGraphicsItem::ItemPositionChange:
+    {
+        QPointF newPos = value.toPointF();
+        if (snapToGrid()) {
+            newPos =_settings.snapToGrid(newPos);
+        }
+        return newPos;
+    }
+    case QGraphicsItem::ItemParentChange:
+        if (parentObject()) {
+            disconnect(parentObject(), nullptr, this, nullptr);
+        }
+        return value;
+    case QGraphicsItem::ItemParentHasChanged:
+    {
+        Item* parent = static_cast<Item*>(parentItem());
+        if (parent) {
+            connect(parent, &Item::moved, this, &Item::scenePosChanged);
+            connect(parent, &Item::rotated, this, &Item::scenePosChanged);
+        }
+        return value;
+    }
+
+    default:
+        return QGraphicsItem::itemChange(change, value);
+    }
+}
+
+void Item::posChanged()
+{
+    scenePosChanged();
+    const QPointF& newPos = pos();
+    QVector2D movedBy(newPos - _oldPos);
+    if (!movedBy.isNull()) {
+        emit moved(*this, movedBy);
+    }
+
+    _oldPos = newPos;
+}
+
+void Item::scenePosChanged()
+{
+    emit movedInScene(*this);
+}
+
+void Item::rotChanged()
+{
+    const qreal newRot = rotation();
+    qreal rotationChange = newRot - _oldRot;
+    if (!qFuzzyIsNull(rotationChange)) {
+        emit rotated(*this, rotationChange);
+    }
+
+    _oldRot = newRot;
+}
+
+void Item::update()
+{
+    // All transformations happen around the center of the item
+    setTransformOriginPoint(boundingRect().width()/2, boundingRect().height()/2);
+
+    // Base class
+    QGraphicsObject::update();
+}
+
diff --git a/src/sw/noc_dev/IPStudio_qt6/GUI/WireItem/scene.cpp b/src/sw/noc_dev/IPStudio_qt6/GUI/WireItem/scene.cpp
index fbcf0eb1c23..932120b07bb 100644
--- a/src/sw/noc_dev/IPStudio_qt6/GUI/WireItem/scene.cpp
+++ b/src/sw/noc_dev/IPStudio_qt6/GUI/WireItem/scene.cpp
@@ -1,2123 +1,2127 @@
-#include <algorithm>
-#include <QPainter>
-#include <QGraphicsSceneMouseEvent>
-#include <QXmlStreamWriter>
-#include <QUndoStack>
-#include <QMimeData>
-#include <QtMath>
-#include <QTimer>
-#include <QFileDialog>
-
-#include "scene.h"
-#include "commanditemmove.h"
-#include "commanditemadd.h"
-#include "commanditemremove.h"
-#include "commandconnectormove.h"
-#include "itemfactory.h"
-#include "item.h"
-#include "itemmimedata.h"
-#include "node.h"
-#include "label.h"
-#include "itemscontainerutils.h"
-#include "itemtypes.h"
-#include "IPInstance.h"
-#include <QFile>
-#include "IPDialog.h"
-#include "global.h"
-#include <QTextStream>
-#include <QDataStream>
-#include <QIODevice>
-#include "IPConnectivity.h"
-#include "../MainWindow/MainWindow.h"
-#include "../libavoid/libavoid/libavoid.h"
-#include "../../include/IPInstancesTable.h"
-
-using namespace QSchematic;
-
-QPair<QList<std::shared_ptr<Wire>>, QList<IPConnectivity*>> _highlightedList;
-
-Scene::Scene(QObject* parent) :
-    QGraphicsScene(parent),
-    _mode(NormalMode),
-    _newWireSegment(false),
-    _invertWirePosture(true),
-    _movingNodes(false),
-    _highlightedItem(nullptr)
-{
-    // NOTE: still needed, BSP-indexer still crashes on a scene load when
-    // the scene is already populated
-    setItemIndexMethod(ItemIndexMethod::NoIndex);
-
-    // Wire system
-    m_wire_manager = std::make_shared<wire_system::manager>();
-    m_wire_manager->set_net_factory([=] { return std::make_shared<WireNet>(); });
-    connect(m_wire_manager.get(), &wire_system::manager::wire_point_moved, this, &Scene::wirePointMoved);
-
-    // Undo stack
-    _undoStack = new QUndoStack;
-    connect(_undoStack, &QUndoStack::cleanChanged, [this](bool isClean) {
-        emit isDirtyChanged(!isClean);
-    });
-
-    // Stuff
-    connect(this, &QGraphicsScene::sceneRectChanged, [this]{
-        renderCachedBackground();
-    });
-
-    // Prepare the background
-    renderCachedBackground();
-}
-
-bool Scene::addItem(QGraphicsItem* item)
-{
-    if (!item) {
-        return false;
-    }
-    QGraphicsScene::addItem(item);
-
-    return true;
-}
-
-void Scene::setSettings(const Settings& settings)
-{
-    // Update settings of all items
-    for (auto& item : items()) {
-        item->setSettings(settings);
-    }
-
-    // Update settings of the wire manager
-    m_wire_manager->set_settings(settings);
-
-    // Store new settings
-    _settings = settings;
-
-    // Redraw
-    renderCachedBackground();
-    update();
-}
-
-void Scene::setWireFactory(const std::function<std::shared_ptr<Wire>()>& factory)
-{
-    _wireFactory = factory;
-}
-
-void Scene::setMode(int mode)
-{
-    // Dont do anything unnecessary
-    if (mode == _mode) {
-        return;
-    }
-
-    // Check what the previous mode was
-    switch (_mode) {
-
-    // Discard current wire/bus
-    case WireMode:
-        if (_newWire) {
-            _newWire->simplify();
-        }
-        _newWire.reset();
-        break;
-
-    default:
-        break;
-
-    }
-
-    // Store the new mode
-    _mode = mode;
-
-    // Update the UI
-    update();
-
-    // Let the world know
-    emit modeChanged(_mode);
-}
-
-int Scene::mode() const
-{
-    return _mode;
-}
-
-void Scene::toggleWirePosture()
-{
-    _invertWirePosture = !_invertWirePosture;
-}
-
-bool Scene::isDirty() const
-{
-    Q_ASSERT(_undoStack);
-
-    return !_undoStack->isClean();
-}
-
-void Scene::clearIsDirty()
-{
-    Q_ASSERT(_undoStack);
-
-    _undoStack->setClean();
-}
-
-void Scene::clear()
-{
-    // Ensure no lingering lifespans kept in map-keys, selections or undocommands
-    _initialItemPositions.clear();
-    clearSelection();
-    clearFocus();
-    _undoStack->clear();
-
-    // Remove from scene
-    // Do not use QGraphicsScene::clear() as that would also delete the items. However,
-    // we still need them as we manage them via smart pointers (eg. in commands)
-    while (!_items.isEmpty()) {
-        removeItem(_items.first());
-    }
-
-    // Nets
-    m_wire_manager->clear();
-
-    // Now that all the top-level items are safeguarded we can call the underlying scene's clear()
-    QGraphicsScene::clear();
-
-    // NO longer dirty
-    clearIsDirty();
-}
-
-/**
- * Adds an item to the scene
- * \remark When adding an Item to the Scene, there are two possibilities. If the
- * Item is a "Top-Level" Item (it has no parent), then you should use
- * Scene::addItem(). If the Item is the child of another Item then you need to
- * use the superclass' implementation QGraphicsItem::addItem().
- * This is needed to determine which Items should be moved by the scene and which
- * are moved by their parent.
- */
-bool Scene::addItem(const std::shared_ptr<Item>& item)
-{
-    // Sanity check
-    if (!item) {
-        return false;
-    }
-
-    // Setup item
-    setupNewItem(*(item.get()));
-
-    // Add to scene
-    QGraphicsScene::addItem(item.get());
-
-    // Store the shared pointer to keep the item alive for the QGraphicsScene
-    _items << item;
-
-    // Let the world know
-    emit itemAdded(item);
-
-    return true;
-}
-
-bool Scene::removeItem(const std::shared_ptr<Item> item)
-{
-    // Sanity check
-    if (!item)
-        return false;
-
-    // Figure out what area we need to update
-    auto itemBoundsToUpdate = item->mapRectToScene(item->boundingRect());
-
-    // NOTE: Sometimes ghosts remain (not drawn away) when they're active in some way at remove time, found below from looking at Qt-source code...
-    item->clearFocus();
-    item->setFocusProxy(nullptr);
-
-    // Remove from scene (if necessary)
-    QGraphicsScene::removeItem(item.get());
-
-    // Remove shared pointer from local list to reduce instance count
-    _items.removeAll(item);
-
-    // Update the corresponding scene area (redraw)
-    update(itemBoundsToUpdate);
-
-    // Let the world know
-    emit itemRemoved(item);
-
-    // NOTE: In order to keep items alive through this entire event loop round,
-    // otherwise crashes because Qt messes with items even after they're removed
-    // ToDo: Fix this
-    _keep_alive_an_event_loop << item;
-
-    return true;
-}
-
-QList<std::shared_ptr<Item>> Scene::items() const
-{
-    return _items;
-}
-
-QList<std::shared_ptr<Item>> Scene::itemsAt(const QPointF &scenePos, Qt::SortOrder order) const
-{
-    return ItemUtils::mapItemListToSharedPtrList<QList>(QGraphicsScene::items(scenePos, Qt::IntersectsItemShape, order));
-}
-
-QList<std::shared_ptr<Item>> Scene::items(int itemType) const
-{
-    QList<std::shared_ptr<Item>> items;
-
-    for (auto& item : _items) {
-        if (item->type() != itemType) {
-            continue;
-        }
-
-        items << item;
-    }
-
-    return items;
-}
-
-std::vector<std::shared_ptr<Item>> Scene::selectedItems() const
-{
-
-    // 111
-    // auto items = ItemUtils::mapItemListToSharedPtrList<std::vector>(QGraphicsScene::selectedItems());
-
-
-    // 222
-    // const auto& rawItems = QGraphicsScene::selectedItems();
-    // // Retrieve corresponding smart pointers
-    // auto items = std::vector<std::shared_ptr<Item>>{};
-    // items.reserve(rawItems.count());
-    // for ( auto item_ptr : rawItems ) {
-    //     if ( auto qs_item = dynamic_cast<Item*>(item_ptr) ) {
-    //         if ( auto item_sh_ptr = qs_item->sharedPtr() ) {
-    //             items.push_back(item_sh_ptr );
-    //         }
-    //     }
-    // }
-
-    // ???
-    // TODO: XXX
-    // - get items but sort out only those in root(?)
-    // - this will break for group style (ExdDes)
-    // - but QS-demo behaves wickedly if child-items are allowed to be selected since it didn't support that before
-
-    auto items = ItemUtils::mapItemListToSharedPtrList<std::vector>(QGraphicsScene::selectedItems());
-
-    return items;
-}
-
-/**
- * Returns only the selected items that are not part of another item.
- * \remark The top-level items are those that were added to the scene by calling Scene::addItem.
- * Items that should not be top-level items need to be added by using QGraphicsScene::addItem
- * \returns List of selected top-level items
- */
-std::vector<std::shared_ptr<Item>> Scene::selectedTopLevelItems() const
-{
-    const auto& rawItems = QGraphicsScene::selectedItems();
-    std::vector<std::shared_ptr<Item>> items;
-
-    for (auto& item : _items) {
-        if (rawItems.contains(item.get())) {
-            items.push_back(item);
-        }
-    }
-
-    return items;
-}
-
-QList<std::shared_ptr<Node>> Scene::nodes() const
-{
-    QList<std::shared_ptr<Node>> nodes;
-
-    for (auto& item : _items) {
-        auto node = std::dynamic_pointer_cast<Node>(item);
-        if (!node) {
-            continue;
-        }
-
-        nodes << node;
-    }
-
-    return nodes;
-}
-
-std::shared_ptr<Node> Scene::nodeFromConnector(const QSchematic::Connector* connector) const
-{
-    for (auto node : nodes()) {
-        const auto& connectors = node->connectors();
-        auto it = std::find_if(std::cbegin(connectors), std::cend(connectors), [connector](const auto& c) {
-            return c.get() == connector;
-        });
-        if (it != std::cend(connectors))
-            return node;
-    }
-
-    return nullptr;
-}
-
+#include <algorithm>
+#include <QPainter>
+#include <QGraphicsSceneMouseEvent>
+#include <QXmlStreamWriter>
+#include <QUndoStack>
+#include <QMimeData>
+#include <QtMath>
+#include <QTimer>
+#include <QFileDialog>
+
+#include "scene.h"
+#include "commanditemmove.h"
+#include "commanditemadd.h"
+#include "commanditemremove.h"
+#include "commandconnectormove.h"
+#include "itemfactory.h"
+#include "item.h"
+#include "itemmimedata.h"
+#include "node.h"
+#include "label.h"
+#include "itemscontainerutils.h"
+#include "itemtypes.h"
+#include "IPInstance.h"
+#include <QFile>
+#include "IPDialog.h"
+#include "global.h"
+#include <QTextStream>
+#include <QDataStream>
+#include <QIODevice>
+#include "IPConnectivity.h"
+#include "../MainWindow/MainWindow.h"
+#include "../libavoid/libavoid/libavoid.h"
+#include "../../include/IPInstancesTable.h"
+
+using namespace QSchematic;
+
+QPair<QList<std::shared_ptr<Wire>>, QList<IPConnectivity*>> _highlightedList;
+
+Scene::Scene(QObject* parent) :
+    QGraphicsScene(parent),
+    _mode(NormalMode),
+    _newWireSegment(false),
+    _invertWirePosture(true),
+    _movingNodes(false),
+    _highlightedItem(nullptr)
+{
+    // NOTE: still needed, BSP-indexer still crashes on a scene load when
+    // the scene is already populated
+    setItemIndexMethod(ItemIndexMethod::NoIndex);
+
+    // Wire system
+    m_wire_manager = std::make_shared<wire_system::manager>();
+    m_wire_manager->set_net_factory([=] { return std::make_shared<WireNet>(); });
+    connect(m_wire_manager.get(), &wire_system::manager::wire_point_moved, this, &Scene::wirePointMoved);
+
+    // Undo stack
+    _undoStack = new QUndoStack;
+    connect(_undoStack, &QUndoStack::cleanChanged, [this](bool isClean) {
+        emit isDirtyChanged(!isClean);
+    });
+
+    // Stuff
+    connect(this, &QGraphicsScene::sceneRectChanged, [this]{
+        renderCachedBackground();
+    });
+
+    // Prepare the background
+    renderCachedBackground();
+}
+
+bool Scene::addItem(QGraphicsItem* item)
+{
+    if (!item) {
+        return false;
+    }
+    QGraphicsScene::addItem(item);
+
+    return true;
+}
+
+void Scene::setSettings(const Settings& settings)
+{
+    // Update settings of all items
+    for (auto& item : items()) {
+        item->setSettings(settings);
+    }
+
+    // Update settings of the wire manager
+    m_wire_manager->set_settings(settings);
+
+    // Store new settings
+    _settings = settings;
+
+    // Redraw
+    renderCachedBackground();
+    update();
+}
+
+void Scene::setWireFactory(const std::function<std::shared_ptr<Wire>()>& factory)
+{
+    _wireFactory = factory;
+}
+
+void Scene::setMode(int mode)
+{
+    // Dont do anything unnecessary
+    if (mode == _mode) {
+        return;
+    }
+
+    // Check what the previous mode was
+    switch (_mode) {
+
+    // Discard current wire/bus
+    case WireMode:
+        if (_newWire) {
+            _newWire->simplify();
+        }
+        _newWire.reset();
+        break;
+
+    default:
+        break;
+
+    }
+
+    // Store the new mode
+    _mode = mode;
+
+    // Update the UI
+    update();
+
+    // Let the world know
+    emit modeChanged(_mode);
+}
+
+int Scene::mode() const
+{
+    return _mode;
+}
+
+void Scene::toggleWirePosture()
+{
+    _invertWirePosture = !_invertWirePosture;
+}
+
+bool Scene::isDirty() const
+{
+    Q_ASSERT(_undoStack);
+
+    return !_undoStack->isClean();
+}
+
+void Scene::clearIsDirty()
+{
+    Q_ASSERT(_undoStack);
+
+    _undoStack->setClean();
+}
+
+void Scene::clear()
+{
+    // Ensure no lingering lifespans kept in map-keys, selections or undocommands
+    _initialItemPositions.clear();
+    clearSelection();
+    clearFocus();
+    _undoStack->clear();
+
+    // Remove from scene
+    // Do not use QGraphicsScene::clear() as that would also delete the items. However,
+    // we still need them as we manage them via smart pointers (eg. in commands)
+    while (!_items.isEmpty()) {
+        removeItem(_items.first());
+    }
+
+    // Nets
+    m_wire_manager->clear();
+
+    // Now that all the top-level items are safeguarded we can call the underlying scene's clear()
+    QGraphicsScene::clear();
+
+    // NO longer dirty
+    clearIsDirty();
+}
+
+/**
+ * Adds an item to the scene
+ * \remark When adding an Item to the Scene, there are two possibilities. If the
+ * Item is a "Top-Level" Item (it has no parent), then you should use
+ * Scene::addItem(). If the Item is the child of another Item then you need to
+ * use the superclass' implementation QGraphicsItem::addItem().
+ * This is needed to determine which Items should be moved by the scene and which
+ * are moved by their parent.
+ */
+bool Scene::addItem(const std::shared_ptr<Item>& item)
+{
+    // Sanity check
+    if (!item) {
+        return false;
+    }
+
+    // Setup item
+    setupNewItem(*(item.get()));
+
+    // Add to scene
+    QGraphicsScene::addItem(item.get());
+
+    // Store the shared pointer to keep the item alive for the QGraphicsScene
+    _items << item;
+
+    // Let the world know
+    emit itemAdded(item);
+
+    return true;
+}
+
+bool Scene::removeItem(const std::shared_ptr<Item> item)
+{
+    // Sanity check
+    if (!item)
+        return false;
+
+    // Figure out what area we need to update
+    auto itemBoundsToUpdate = item->mapRectToScene(item->boundingRect());
+
+    // NOTE: Sometimes ghosts remain (not drawn away) when they're active in some way at remove time, found below from looking at Qt-source code...
+    item->clearFocus();
+    item->setFocusProxy(nullptr);
+
+    // Remove from scene (if necessary)
+    QGraphicsScene::removeItem(item.get());
+
+    // Remove shared pointer from local list to reduce instance count
+    _items.removeAll(item);
+
+    // Update the corresponding scene area (redraw)
+    update(itemBoundsToUpdate);
+
+    // Let the world know
+    emit itemRemoved(item);
+
+    // NOTE: In order to keep items alive through this entire event loop round,
+    // otherwise crashes because Qt messes with items even after they're removed
+    // ToDo: Fix this
+    _keep_alive_an_event_loop << item;
+
+    return true;
+}
+
+QList<std::shared_ptr<Item>> Scene::items() const
+{
+    return _items;
+}
+
+QList<std::shared_ptr<Item>> Scene::itemsAt(const QPointF &scenePos, Qt::SortOrder order) const
+{
+    return ItemUtils::mapItemListToSharedPtrList<QList>(QGraphicsScene::items(scenePos, Qt::IntersectsItemShape, order));
+}
+
+QList<std::shared_ptr<Item>> Scene::items(int itemType) const
+{
+    QList<std::shared_ptr<Item>> items;
+
+    for (auto& item : _items) {
+        if (item->type() != itemType) {
+            continue;
+        }
+
+        items << item;
+    }
+
+    return items;
+}
+
+std::vector<std::shared_ptr<Item>> Scene::selectedItems() const
+{
+
+    // 111
+    // auto items = ItemUtils::mapItemListToSharedPtrList<std::vector>(QGraphicsScene::selectedItems());
+
+
+    // 222
+    // const auto& rawItems = QGraphicsScene::selectedItems();
+    // // Retrieve corresponding smart pointers
+    // auto items = std::vector<std::shared_ptr<Item>>{};
+    // items.reserve(rawItems.count());
+    // for ( auto item_ptr : rawItems ) {
+    //     if ( auto qs_item = dynamic_cast<Item*>(item_ptr) ) {
+    //         if ( auto item_sh_ptr = qs_item->sharedPtr() ) {
+    //             items.push_back(item_sh_ptr );
+    //         }
+    //     }
+    // }
+
+    // ???
+    // TODO: XXX
+    // - get items but sort out only those in root(?)
+    // - this will break for group style (ExdDes)
+    // - but QS-demo behaves wickedly if child-items are allowed to be selected since it didn't support that before
+
+    auto items = ItemUtils::mapItemListToSharedPtrList<std::vector>(QGraphicsScene::selectedItems());
+
+    return items;
+}
+
+/**
+ * Returns only the selected items that are not part of another item.
+ * \remark The top-level items are those that were added to the scene by calling Scene::addItem.
+ * Items that should not be top-level items need to be added by using QGraphicsScene::addItem
+ * \returns List of selected top-level items
+ */
+std::vector<std::shared_ptr<Item>> Scene::selectedTopLevelItems() const
+{
+    const auto& rawItems = QGraphicsScene::selectedItems();
+    std::vector<std::shared_ptr<Item>> items;
+
+    for (auto& item : _items) {
+        if (rawItems.contains(item.get())) {
+            items.push_back(item);
+        }
+    }
+
+    return items;
+}
+
+QList<std::shared_ptr<Node>> Scene::nodes() const
+{
+    QList<std::shared_ptr<Node>> nodes;
+
+    for (auto& item : _items) {
+        auto node = std::dynamic_pointer_cast<Node>(item);
+        if (!node) {
+            continue;
+        }
+
+        nodes << node;
+    }
+
+    return nodes;
+}
+
+std::shared_ptr<Node> Scene::nodeFromConnector(const QSchematic::Connector* connector) const
+{
+    for (auto node : nodes()) {
+        const auto& connectors = node->connectors();
+        auto it = std::find_if(std::cbegin(connectors), std::cend(connectors), [connector](const auto& c) {
+            return c.get() == connector;
+        });
+        if (it != std::cend(connectors))
+            return node;
+    }
+
+    return nullptr;
+}
+
 std::shared_ptr<Wire> Scene::makeWire()
 {
-    std::shared_ptr<Wire> _newWire;
-    if (_wireFactory) {
-        _newWire = _wireFactory();
-    } else {
-        _newWire = std::make_shared<Wire>();
+    std::shared_ptr<Wire> _newWire;
+    if (_wireFactory) {
+        _newWire = _wireFactory();
+    } else {
+        _newWire = std::make_shared<Wire>();
     }
     undoStack()->push(new CommandItemAdd(this, _newWire));
     return _newWire;
 }
 
-void Scene::undo()
-{
-    _undoStack->undo();
-}
-
-void Scene::redo()
-{
-    _undoStack->redo();
-}
-
-QUndoStack* Scene::undoStack() const
-{
-    return _undoStack;
-}
-
-std::shared_ptr<wire_system::manager> Scene::wire_manager() const
-{
-    return m_wire_manager;
-}
-
-void Scene::setFocusItem(const QString& instName, bool zoom)
-{
-    for(auto const& it : _items)
-    {
-        auto inst = dynamic_cast<IPInstance*>(it.get());
-        if (inst)
-        {
-            inst->setSelected(false);
-            if (inst->getinstanceName() == instName)
-            {
-                if (!zoom) {
-                    inst->setSelected(true);
-                }
-                auto item = it.get();
-                if (QApplication::keyboardModifiers() & Qt::ControlModifier) {
-                    if (_selectedItems.contains(item)) {                                            
-                        item->setHighlighted(false);                          
-                        item->update();
-                        emit item->highlightChanged(*item, false);
-                        _selectedItems.removeOne(item);
-                    } else {
-                        item->setHighlighted(true);
-                        item->update();
-                        emit item->highlightChanged(*item, true);
-                        if (!_selectedItems.contains(item)) {  
-                            _selectedItems.push_back(item);
-                        }
-                    }
-                } else {
-                    if (!_selectedItems.empty()) {
-                        // Disable all highlighted items
-                        for (auto const& it : _items) {
-                            it->setHighlighted(false);
-                            it->update();
-                            emit it->highlightChanged(*it, false);
-                        }
-                        _selectedItems.clear();
-                    }
-
-                    clearSelection();
-                    // Highlight the item
-                    item->setHighlighted(true);
-                    item->update();
-                    emit item->highlightChanged(*item, true);                   
-                    _selectedItems.push_back(item);
-                }
-
-                _highlightedItem = nullptr;
-                if (zoom) {
-                    // Zoom to item
-                    emit zoomItem(item);
-                }
-                break;
-            }
-        }
-    }
-}
-
-void Scene::undoItems()
-{
-    undo();
-}
-
-void Scene::redoItems()
-{
-    redo();
-}
-
-void Scene::resetView() {
-    int max = _undoStack->count();
-    for (int i = 0; i < max; i++) {
-        undo();
-    }
-}
-
-void Scene::keyPressEvent(QKeyEvent* event)
-{
-    if (event->matches(QKeySequence::Undo)) {
-        undo();
-    } else if (event->matches(QKeySequence::Redo)) {
-        redo();
-    } 
-}
-
-void Scene::mousePressEvent(QGraphicsSceneMouseEvent* event) {
-    event->accept();
-
-    switch (_mode) {
-        case NormalMode:
-        {
-            // Reset stuff
-            _newWire = {};
-
-            // Handle selections
-            QGraphicsScene::mousePressEvent(event);
-
-            // Check if moving nodes
-            QGraphicsItem* item = itemAt(event->scenePos(), QTransform());
-            if (item) {
-                Node* node = dynamic_cast<Node*>(item);
-                if (node && node->mode() == Node::None) {
-                    _movingNodes = true;
-                } else {
-                    _movingNodes = false;
-                }
-                auto inst = dynamic_cast<IPInstance*>(item);
-                if (inst) {
-                    auto mw = dynamic_cast<IPMainWindow*>(QApplication::activeWindow());
-                    mw->getInstanceDock()->setWidget(mw->getModulesTab());
-                    mw->getInstanceDock()->setWindowTitle("Instances");
-                }
-                // Prevent the scene from detecting changes in the wires origin
-                // when the bouding rect is resized by a wire_point that moved
-                Wire* wire = dynamic_cast<Wire*>(item);
-                if (wire) {
-                    if (wire->movingWirePoint()) {
-                        _movingNodes = false;
-                    } else {
-                        _movingNodes = true;
-                    }
-                }
-
-                Label* label = dynamic_cast<Label*>(item);
-                if (label) {
-                    if (event->button() == Qt::RightButton) {
-                        /* QInputDialog dialog;
-                        dialog.setWindowTitle("Rename Label");
-                        dialog.setLabelText(tr("New Name:"));
-                        dialog.setWindowFlags(Qt::Window | Qt::WindowCloseButtonHint | Qt::CustomizeWindowHint);
-                        dialog.resize(QSize(300, 300));
-                        dialog.move(QCursor::pos());
-                        if (dialog.exec()) {
-                            QString text = dialog.textValue();
-                            if (text.length() > 0) {
-                                // Update label related to the connector
-                                label->setText(text);
-
-                                // Update connector name
-                                Connector* conn = dynamic_cast<Connector*>(label->parentItem());
-                                if (conn) {
-                                    conn->setNewName(text);
-                                    std::shared_ptr<Node> node = nodeFromConnector(conn);
-                                    if (node) {
-                                        node->alignConnectorLabels();
-                                    }
-                                }                           
-                            }
-                        }*/
-                        auto ipconn = dynamic_cast<IPConnectivity*>(label->parentItem());
-                        if (ipconn) {
-                            auto tabledialog = new tableDialog(ipconn->getInstanceName().toStdString(), label->text().toStdString());
-                            tabledialog->exec();
-                        }
-                    } else if (event->button() == Qt::LeftButton) {
-                        /* Show connectivity net of interface */
-                        auto ipconn = dynamic_cast<IPConnectivity*>(label->parentItem());
-                        auto mw = dynamic_cast<IPMainWindow*>(QApplication::activeWindow());
-                        if (mw && ipconn) {
-                            QList<QString> ifce_name = {label->text()};
-                            _renderWireList = mw->getIPDesign()->renderWires(ipconn->getInstanceName(), ifce_name, _renderWireList);
-                            auto ipDesign = mw->getIPDesign();
-                            if (ipDesign) {
-                                auto mp =
-                                    ipDesign->findInstanceAndInterface(ipconn->getInstanceName().toStdString(),
-                                                                       label->text().toStdString());
-                                if (!mp.isEmpty()) {
-                                    auto mod = ipDesign->getModule();
-                                    if (mod) {
-                                        auto inst        = mp.firstKey();
-                                        auto ifce        = mp[inst];
-                                        auto md          = const_cast<NetSpeed::BDS::Module*>(mod);
-                                        std::string html = md->GetToolTip(inst, ifce);
-                                        QTextEdit* tooltipWindow = new QTextEdit;
-                                        tooltipWindow->setObjectName(OBJ_TOOLTIP_TAB_WIDGET);
-                                        tooltipWindow->setReadOnly(true);
-                                        tooltipWindow->setText(QString::fromStdString(html));
-                                        mw->getInstanceDock()->setWidget(tooltipWindow);
-                                        mw->getInstanceDock()->setWindowTitle("Tooltip");
-                                    }
-                                }
-                            }         
-                        }
-                        
-                        if (_highlightedItem) {
-                            Connector* conn = dynamic_cast<Connector*>(label->parentItem());
-                            if (conn) {
-                                conn->setSelected(true);
-                                _connSelected = conn;
-                                _old_pos = conn->pos();
-                                std::shared_ptr<Node> node = nodeFromConnector(conn);
-                                if (node) {
-                                    _node = node.get();
-                                    _movingNodes = false;
-                                }
-                            }
-                        }
-                    }
-
-                    if (selectedTopLevelItems().size() > 0) {
-                        _movingNodes = true;
-                    }
-                }
-
-                if (_highlightedItem) {
-                    Connector* conn = dynamic_cast<Connector*>(item);
-                    if (conn) {
-                        _connSelected = conn;
-                        _old_pos = conn->pos();
-                        std::shared_ptr<Node> node = nodeFromConnector(conn);
-                        if (node) {
-                            _node = node.get();
-                            _movingNodes = false;
-                        }
-                    }
-                }               
-            } else {
-                _movingNodes = false;
-                if (!event->modifiers().testFlag(Qt::ControlModifier)) {
-                    for (auto const& it : _items) {
-                        if (it->isHighlighting()) {
-                            it->setHighlighted(false);
-                            it->update();
-                            emit it->highlightChanged(*it, false);
-                        }
-                    }
-                    _selectedItems.clear();
-                    emit disableHilightedItems();
-                    auto mw = dynamic_cast<IPMainWindow*>(QApplication::activeWindow());
-                    if (mw) {
-                        auto proper = mw->getPropertyPanel();
-                        if (proper) {
-                            proper->clearAll();
-                        }
-                    }
-                }
-
-                if (event->button() == Qt::LeftButton) {
-                    /* Clear _renderWireList */
-                    for (auto item : _renderWireList) {
-                        removeWire(item);
-                    }
-                    _renderWireList.clear();
-                }
-            }
-
-            // Store the initial position of all the selected items
-            _initialItemPositions.clear();
-            for (auto& item: selectedTopLevelItems()) {
-                if (item) {
-                    _initialItemPositions.insert(item, item->pos());
-                }
-            }
-
-            // Store the initial cursor position
-            _initialCursorPosition = event->scenePos();
-
-            break;
-        }
-
-        case WireMode:
-        {
-
-            // Left mouse button
-            if (event->button() == Qt::LeftButton) {
-
-                // Start a new wire if there isn't already one. Else continue the current one.
-                if (!_newWire) {
-                    _newWire = makeWire();
-                    _newWire->setPos(_settings.snapToGrid(event->scenePos()));
-                    _newWire->setItemType(ItemType::ManualWireType);
-                }
-                // Snap to grid
-            
-
-                auto appendPoint = [&](const QPointF point) {
-                    _newWire->append_point(point);
-                    _newWireSegment = true;
-                };
-                // Attach point to connector if needed
-                bool wireAttached = false;
-                for (const auto& node: nodes()) {
-                    for (const auto& connector: node->connectors()) {
-                        if (connector->sceneBoundingRect().adjusted(-1, -1, 1, 1).contains(event->scenePos())) {
-                            const QPointF& snappedPos = _settings.snapToGrid(connector->scenePos());
-                            appendPoint(snappedPos);
-                            m_wire_manager->attach_wire_to_connector(_newWire.get(), _newWire->pointsAbsolute().indexOf(snappedPos),
-                                                                     connector.get());
-                            wireAttached = true;
-                            break;
-                        }
-                    }
-                }
-
-                if (!wireAttached) appendPoint(_settings.snapToGrid(event->scenePos()));
-            
-                // Attach point to wire if needed
-                for (const auto& wire: m_wire_manager->wires()) {
-                    // Skip current wire
-                    if (wire == _newWire) {
-                        continue;
-                    }
-                    if (wire->point_is_on_wire(_newWire->pointsAbsolute().last())) {
-                        m_wire_manager->connect_wire(wire.get(), _newWire.get(), _newWire->pointsAbsolute().count() - 1);
-                        wireAttached = true;
-                        break;
-                    }
-                }
-
-                // Check if both ends of the wire are connected to something
-                if (wireAttached && _newWire->pointsAbsolute().count() > 1) {
-                    finishCurrentWire();
-                }
-
-            }
-
-            break;
-        }
-    }
-
-    _lastMousePos = event->scenePos();
-}
-
-bool Scene::forceConnectorPos()
-{
-    bool ret = false;
-
-    for (auto& conn : _node->connectors()) {
-        if ((qFuzzyCompare(conn->posX(), _connSelected->posX())) &&
-            (qFuzzyCompare(conn->posY(), _connSelected->posY()))) {
-            if (_connSelected != conn.get()) {
-                _undoStack->push(new CommandConnectorMove(_connSelected, _connSelected->pos(), _old_pos));
-                _connSelected = conn.get();
-                _old_pos = _connSelected->pos();
-                ret = true;
-                break;
-            }
-        }
-    }
-
-    return (ret);
-}
-
-bool Scene::checkPinsOverlap()
-{
-    bool ret = false;
-    
-    for (auto& conn : _node->connectors()) {
-        if ((qFuzzyCompare(conn->posX(), _connSelected->posX())) &&
-            (qFuzzyCompare(conn->posY(), _connSelected->posY()))) {
-            if (_connSelected != conn.get()) {
-                ret = true;
-                break;
-            }
-        }
-    }
-
-    return (ret);
-}
-
-bool Scene::checkPinsEquidistance(int edge) {
-    bool ret = false;
-    int max_node = 0;
-    int x = 0;
-    int y = 0;
-    int grid = _settings.gridSize << 1;
-
-    switch (edge) {
-        case LEFT:
-            max_node = (_node->height() - grid) / grid + 1;
-            y = _node->height() - _settings.gridSize;
-            for (int i = 0; i < max_node; i++) {
-                if (qFuzzyCompare(y, _connSelected->posY())) {
-                    ret = true;
-                }
-                y -= grid;
-            }
-            break;
-
-        case TOP:
-            max_node = (_node->width() - grid) / grid + 1;
-            x = grid;
-            for (int i = 0; i < max_node; i++) {
-                if (qFuzzyCompare(x, _connSelected->posX()) || (_connSelected->posX() <= grid) ||
-                    (_connSelected->posX() > (max_node * grid))) {
-                    ret = true;
-                    break;
-                }
-                x += grid;
-            }
-            break;
-
-        case RIGHT:
-            max_node = (_node->height() - grid) / grid + 1;
-            y = grid + _settings.gridSize;
-            for (int i = 0; i < max_node; i++) {
-                if (qFuzzyCompare(y, _connSelected->posY()) || (_connSelected->posY() <= grid)) {
-                    ret = true;
-                    break;
-                }
-                y += grid;
-            }
-            break;
-
-        case BOTTOM:
-            max_node = (_node->width() - grid) / grid + 1;
-            x = _node->width() - _settings.gridSize;
-            for (int i = 0; i < max_node; i++) {
-                if (qFuzzyCompare(x, _connSelected->posX()) || (_connSelected->posX() <= grid)) {
-                    ret = true;
-                    break;
-                }
-                x -= grid;
-            }
-            break;
-
-        default:
-            /* Do nothing */
-            break;
-    }
-
-    return (ret);
-}
-
-void Scene::checkPinsOverlapLeft()
-{
-    bool ret = false;
-    int max_node = 0;
-    int x = 0;
-    int y = 0;
-    int grid = _settings.gridSize << 1;
-
-    max_node = (_node->height() - grid) / grid;    
-    y = _node->height() - grid - _settings.gridSize;
-    _connSelected->setPosY(y);
-    if (!checkPinsOverlap()) {        
-        y = _node->height() - grid;
-    }
-
-    for (int i = 0; i < max_node; i++) {
-        _connSelected->setPosY(y);
-        if (!checkPinsOverlap()) {
-            ret = true;
-            break;
-        }
-        y -= grid;
-    }
-
-    if (!ret) {
-        /* Enter check Top edge */
-        _connSelected->setPosY(0);
-        max_node = (_node->width() - grid) / grid;
-        x = grid;
-        _connSelected->setPosX(x);
-        if (!checkPinsOverlap()) {
-            x += _settings.gridSize;
-        }
-        for (int i = 0; i < max_node; i++) {
-            _connSelected->setPosX(x);
-            if (!checkPinsOverlap()) {
-                ret = true;
-                break;
-            }
-            x += grid;
-        }
-    }
-      
-    if (!ret) {
-        /* Enter check Right edge */
-        _connSelected->setPosX(_node->width());
-        int h = _node->height();
-        max_node = (h - grid) / grid;
-        y = grid + _settings.gridSize;
-        _connSelected->setPosY(y);
-        if (!checkPinsOverlap()) {
-            y = grid;
-        }
-        for (int i = 0; i < max_node; i++) {
-            _connSelected->setPosY(y);
-            if (!checkPinsOverlap()) {
-                ret = true;
-                break;
-            }
-            y += grid;
-        }
-    }
-
-    if (!ret) {
-        /* Enter check Bottom edge */
-        _connSelected->setPosY(_node->height());
-        int w = _node->width();
-        max_node = (w - grid) / grid;
-        x = w - grid - _settings.gridSize;
-        _connSelected->setPosX(x);
-        if (!checkPinsOverlap()) {
-            x = w - grid;
-        }
-        for (int i = 0; i < max_node; i++) {
-            _connSelected->setPosX(x);
-            if (!checkPinsOverlap()) {
-                ret = true;
-                break;
-            }
-            x -= grid;
-        }
-    }
-}
-
-void Scene::checkPinsOverlapTop()
-{
-    bool ret = false;
-    int max_node = 0;
-    int x = 0;
-    int y = 0;
-    int grid = _settings.gridSize << 1;
-
-    
-    max_node = (_node->width() - grid) / grid;
-
-    x = grid;
-    _connSelected->setPosX(x);
-    if (!checkPinsOverlap()) {
-        x += _settings.gridSize;
-    }
-
-    for (int i = 0; i < max_node; i++) {
-        _connSelected->setPosX(x);
-        if (!checkPinsOverlap()) {
-            ret = true;
-            break;
-        }
-        x += grid;
-    }
-
-    if (!ret) {
-        /* Enter to check Right edge */
-        _connSelected->setPosX(_node->width());
-        int h = _node->height();
-        max_node = (h - grid) / grid;
-        y = grid + _settings.gridSize;
-        _connSelected->setPosY(y);
-        if (!checkPinsOverlap()) {
-            y = grid;
-        }
-        for (int i = 0; i < max_node; i++) {
-            _connSelected->setPosY(y);
-            if (!checkPinsOverlap()) {
-                ret = true;
-                break;
-            }
-            y += grid;
-        }
-    }
-
-    if (!ret) {
-        /* Enter to check Bottom edge */
-        _connSelected->setPosY(_node->height());
-        int w = _node->width();
-        max_node = (w - grid) / grid;
-        x = w - grid - _settings.gridSize;
-        _connSelected->setPosX(x);
-        if (!checkPinsOverlap()) {
-            x = w - grid;
-        }
-        for (int i = 0; i < max_node; i++) {
-            _connSelected->setPosX(x);
-            if (!checkPinsOverlap()) {
-                ret = true;
-                break;
-            }
-            x -= grid;
-        }
-    }
-
-    if (!ret) {
-        /* Enter to check Left edge */
-        _connSelected->setPosX(0);
-        max_node = (_node->height() - grid) / grid;
-        y = _node->height() - grid - _settings.gridSize;
-        _connSelected->setPosY(y);
-        if (!checkPinsOverlap()) {
-            y = _node->height() - grid;
-        }
-        for (int i = 0; i < max_node; i++) {
-            _connSelected->setPosY(y);
-            if (!checkPinsOverlap()) {
-                ret = true;
-                break;
-            }
-            y -= grid;
-        }
-    }
-}
-
-void Scene::checkPinsOverlapRight()
-{
-    bool ret = false;
-    int max_node = 0;
-    int x = 0;
-    int y = 0;
-    int grid = _settings.gridSize << 1;
-   
-    int h = _node->height();
-    max_node = (h - grid) / grid;
-    y = grid + _settings.gridSize;
-    _connSelected->setPosY(y);
-    if (!checkPinsOverlap()) {
-        y = grid;
-    }
-    for (int i = 0; i < max_node; i++) {
-        _connSelected->setPosY(y);
-        if (!checkPinsOverlap()) {
-            ret = true;
-            break;
-        }
-        y += grid;
-    }
-
-    if (!ret) {
-        /* Enter to check Bottom edge */
-        _connSelected->setPosY(_node->height());
-        int w = _node->width();
-        max_node = (w - grid) / grid;
-        x = w - grid - _settings.gridSize;
-        _connSelected->setPosX(x);
-        if (!checkPinsOverlap()) {
-            x = w - grid;
-        }
-        for (int i = 0; i < max_node; i++) {
-            _connSelected->setPosX(x);
-            if (!checkPinsOverlap()) {
-                ret = true;
-                break;
-            }
-            x -= grid;
-        }
-    }
-
-    if (!ret) {
-        /* Enter to check Left edge */
-        _connSelected->setPosX(0);
-        max_node = (_node->height() - grid) / grid;
-        y = _node->height() - grid - _settings.gridSize;
-        _connSelected->setPosY(y);
-        if (!checkPinsOverlap()) {
-            y = _node->height() - grid;
-        }
-        for (int i = 0; i < max_node; i++) {
-            _connSelected->setPosY(y);
-            if (!checkPinsOverlap()) {
-                ret = true;
-                break;
-            }
-            y -= grid;
-        }
-    }
-
-    if (!ret) {
-        /* Enter to check Top edge */
-        max_node = (_node->width() - grid) / grid;
-        x = grid;
-        _connSelected->setPosX(x);
-        if (!checkPinsOverlap()) {
-            x += _settings.gridSize;
-        }
-        for (int i = 0; i < max_node; i++) {
-            _connSelected->setPosX(x);
-            if (!checkPinsOverlap()) {
-                ret = true;
-                break;
-            }
-            x += grid;
-        }
-    }
-}
-
-void Scene::checkPinsOverlapBottom()
-{
-    bool ret = false;
-    int max_node = 0;
-    int x = 0;
-    int y = 0;
-    int grid = _settings.gridSize << 1;
-   
-    int w = _node->width();
-    max_node = (w - grid) / grid;    
-    x = w - grid - _settings.gridSize;
-    _connSelected->setPosX(x);
-    if (!checkPinsOverlap()) {
-        x = w - grid;
-    }
-    for (int i = 0; i < max_node; i++) {
-        _connSelected->setPosX(x);
-        if (!checkPinsOverlap()) {
-            ret = true;
-            break;
-        }
-        x -= grid;
-    }
-
-    if (!ret) {
-        /* Enter to check Left edge */
-        _connSelected->setPosX(0);
-        max_node = (_node->height() - grid) / grid;
-        y = _node->height() - grid - _settings.gridSize;
-        _connSelected->setPosY(y);
-        if (!checkPinsOverlap()) {
-            y = _node->height() - grid;
-        }
-        for (int i = 0; i < max_node; i++) {
-            _connSelected->setPosY(y);
-            if (!checkPinsOverlap()) {
-                ret = true;
-                break;
-            }
-            y -= grid;
-        }
-    }
-
-    if (!ret) {
-        /* Enter to check Top edge */
-        max_node = (_node->width() - grid) / grid;
-        x = grid;
-        _connSelected->setPosX(x);
-        if (!checkPinsOverlap()) {
-            x += 10;
-        }
-        for (int i = 0; i < max_node; i++) {
-            _connSelected->setPosX(x);
-            if (!checkPinsOverlap()) {
-                ret = true;
-                break;
-            }
-            x += grid;
-        }
-    }
-
-    if (!ret) {
-        /* Enter to check Right edge */
-        _connSelected->setPosX(_node->width());
-        int h = _node->height();
-        max_node = (h - grid) / grid;
-        y = grid;
-        _connSelected->setPosY(y);
-        if (!checkPinsOverlap()) {
-            y += 10;
-        }
-        for (int i = 0; i < max_node; i++) {
-            _connSelected->setPosY(y);
-            if (!checkPinsOverlap()) {
-                ret = true;
-                break;
-            }
-            y += grid;
-        }
-    }
-}
-
-
-void Scene::mouseReleaseEvent(QGraphicsSceneMouseEvent* event)
-{
-    event->accept();
-
-    switch (_mode) {
-    case NormalMode:
-    {
-        QGraphicsScene::mouseReleaseEvent(event);
-
-        for (const auto& net : m_wire_manager->nets()) {
-
-            // Make sure it's a WireNet
-            auto wire_net = std::dynamic_pointer_cast<WireNet>(net);
-            if (!wire_net) {
-                continue;
-            }
-
-            wire_net->updateLabelPos(true);
-        }
-        // Reset the position for every selected item and
-        // apply the translation through the undostack
-        if (_movingNodes) {
-            QVector<std::shared_ptr<Item>> wiresToMove;
-            QVector<std::shared_ptr<Item>> itemsToMove;
-
-            for (const auto& item : selectedTopLevelItems()) {
-                if (item->isMovable() && _initialItemPositions.contains(item)) {
-                    Wire* wire = dynamic_cast<Wire*>(item.get());
-                    if (wire) {
-                        wiresToMove << item;
-                    } else {
-                        itemsToMove << item;
-                    }
-                }
-            }
-
-            itemsToMove = wiresToMove << itemsToMove;
-            bool needsToMove = false;
-            QVector<QVector2D> moveByList;
-
-            for (const auto& item : itemsToMove) {
-                // Move the item if it is movable and it was previously registered by the mousePressEvent
-                QVector2D moveBy(item->pos() - _initialItemPositions.value(item));
-                // Move the item to its initial position
-                item->setPos(_initialItemPositions.value(item));
-                // Add the moveBy to the list
-                moveByList << moveBy;
-                if (!moveBy.isNull()) {
-                    needsToMove = true;
-                }
-            }
-            // Apply the translation
-            if (needsToMove) {
-                _undoStack->push(new CommandItemMove(itemsToMove, moveByList));
-            }
-            for (const auto& item : itemsToMove) {
-                const Node* node = dynamic_cast<const Node*>(item.get());
-                if (node) {
-                    updateNodeConnections(node);
-                }
-            }
-
-            for (auto& item : m_wire_manager->wires()) {
-                Wire* wire = dynamic_cast<Wire*>(item.get());
-                if (wire) {
-//                    wire->updatePosition();
-                    wire->simplify();
-                }
-            }
-        } else {
-            if (_connSelected && _node) {          
-                 if (forceConnectorPos()) {
-                    if (_connSelected->posX() == 0) {                        
-                        checkPinsOverlapLeft(); 
-                    } else if (_connSelected->posY() == 0) {                 
-                        checkPinsOverlapTop(); 
-                    } else if (_connSelected->posX() == _node->width()) {    
-                        checkPinsOverlapRight(); 
-                    } else {                                                    
-                        checkPinsOverlapBottom();  
-                    }
-                 } else {
-                     if (_connSelected->posX() == 0) {
-                         if (checkPinsEquidistance(LEFT)) {
-                             checkPinsOverlapLeft();
-                         }
-                     } else if (_connSelected->posY() == 0) {
-                         if (checkPinsEquidistance(TOP)) {
-                             checkPinsOverlapTop();
-                         }
-                     } else if (_connSelected->posX() == _node->width()) {
-                         if (checkPinsEquidistance(RIGHT)) {
-                             checkPinsOverlapRight();
-                         }
-                     } else {
-                         if (checkPinsEquidistance(BOTTOM)) {
-                             checkPinsOverlapBottom();
-                         }
-                     }
-                 }
-                _undoStack->push(new CommandConnectorMove(_connSelected, _connSelected->pos(), _old_pos));
-            }
-        }
-
-        if (drag) {           
+void Scene::undo()
+{
+    _undoStack->undo();
+}
+
+void Scene::redo()
+{
+    _undoStack->redo();
+}
+
+QUndoStack* Scene::undoStack() const
+{
+    return _undoStack;
+}
+
+std::shared_ptr<wire_system::manager> Scene::wire_manager() const
+{
+    return m_wire_manager;
+}
+
+void Scene::setFocusItem(const QString& instName, bool zoom)
+{
+    for(auto const& it : _items)
+    {
+        auto inst = dynamic_cast<IPInstance*>(it.get());
+        if (inst)
+        {
+            inst->setSelected(false);
+            if (inst->getinstanceName() == instName)
+            {
+                if (!zoom) {
+                    inst->setSelected(true);
+                }
+                auto item = it.get();
+                if (QApplication::keyboardModifiers() & Qt::ControlModifier) {
+                    if (_selectedItems.contains(item)) {                                            
+                        item->setHighlighted(false);                          
+                        item->update();
+                        emit item->highlightChanged(*item, false);
+                        _selectedItems.removeOne(item);
+                    } else {
+                        item->setHighlighted(true);
+                        item->update();
+                        emit item->highlightChanged(*item, true);
+                        if (!_selectedItems.contains(item)) {  
+                            _selectedItems.push_back(item);
+                        }
+                    }
+                } else {
+                    if (!_selectedItems.empty()) {
+                        // Disable all highlighted items
+                        for (auto const& it : _items) {
+                            it->setHighlighted(false);
+                            it->update();
+                            emit it->highlightChanged(*it, false);
+                        }
+                        _selectedItems.clear();
+                    }
+
+                    clearSelection();
+                    // Highlight the item
+                    item->setHighlighted(true);
+                    item->update();
+                    emit item->highlightChanged(*item, true);                   
+                    _selectedItems.push_back(item);
+                }
+
+                _highlightedItem = nullptr;
+                if (zoom) {
+                    // Zoom to item
+                    emit zoomItem(item);
+                }
+                break;
+            }
+        }
+    }
+}
+
+void Scene::undoItems()
+{
+    undo();
+}
+
+void Scene::redoItems()
+{
+    redo();
+}
+
+void Scene::resetView() {
+    int max = _undoStack->count();
+    for (int i = 0; i < max; i++) {
+        undo();
+    }
+}
+
+void Scene::keyPressEvent(QKeyEvent* event)
+{
+    if (event->matches(QKeySequence::Undo)) {
+        undo();
+    } else if (event->matches(QKeySequence::Redo)) {
+        redo();
+    } 
+}
+
+void Scene::mousePressEvent(QGraphicsSceneMouseEvent* event) {
+    event->accept();
+
+    switch (_mode) {
+        case NormalMode:
+        {
+            // Reset stuff
+            _newWire = {};
+
+            // Handle selections
+            QGraphicsScene::mousePressEvent(event);
+
+            // Check if moving nodes
+            QGraphicsItem* item = itemAt(event->scenePos(), QTransform());
+            if (item) {
+                Node* node = dynamic_cast<Node*>(item);
+                if (node && node->mode() == Node::None) {
+                    _movingNodes = true;
+                } else {
+                    _movingNodes = false;
+                }
+                auto inst = dynamic_cast<IPInstance*>(item);
+                if (inst) {
+                    auto mw = dynamic_cast<IPMainWindow*>(QApplication::activeWindow());
+                    mw->getInstanceDock()->setWidget(mw->getModulesTab());
+                    mw->getInstanceDock()->setWindowTitle("Instances");
+                }
+                // Prevent the scene from detecting changes in the wires origin
+                // when the bouding rect is resized by a wire_point that moved
+                Wire* wire = dynamic_cast<Wire*>(item);
+                if (wire) {
+                    if (wire->movingWirePoint()) {
+                        _movingNodes = false;
+                    } else {
+                        _movingNodes = true;
+                    }
+                }
+
+                Label* label = dynamic_cast<Label*>(item);
+                if (label) {
+                    if (event->button() == Qt::RightButton) {
+                        /* QInputDialog dialog;
+                        dialog.setWindowTitle("Rename Label");
+                        dialog.setLabelText(tr("New Name:"));
+                        dialog.setWindowFlags(Qt::Window | Qt::WindowCloseButtonHint | Qt::CustomizeWindowHint);
+                        dialog.resize(QSize(300, 300));
+                        dialog.move(QCursor::pos());
+                        if (dialog.exec()) {
+                            QString text = dialog.textValue();
+                            if (text.length() > 0) {
+                                // Update label related to the connector
+                                label->setText(text);
+
+                                // Update connector name
+                                Connector* conn = dynamic_cast<Connector*>(label->parentItem());
+                                if (conn) {
+                                    conn->setNewName(text);
+                                    std::shared_ptr<Node> node = nodeFromConnector(conn);
+                                    if (node) {
+                                        node->alignConnectorLabels();
+                                    }
+                                }                           
+                            }
+                        }*/
+                        auto ipconn = dynamic_cast<IPConnectivity*>(label->parentItem());
+                        if (ipconn) {
+                            auto tabledialog = new tableDialog(ipconn->getInstanceName().toStdString(), label->text().toStdString());
+                            tabledialog->exec();
+                        }
+                    } else if (event->button() == Qt::LeftButton) {
+                        /* Show connectivity net of interface */
+                        auto ipconn = dynamic_cast<IPConnectivity*>(label->parentItem());
+                        auto mw = dynamic_cast<IPMainWindow*>(QApplication::activeWindow());
+                        if (mw && ipconn) {
+                            QList<QString> ifce_name = {label->text()};
+                            _renderWireList = mw->getIPDesign()->renderWires(ipconn->getInstanceName(), ifce_name, _renderWireList);
+                            auto ipDesign = mw->getIPDesign();
+                            if (ipDesign) {
+                                auto mp =
+                                    ipDesign->findInstanceAndInterface(ipconn->getInstanceName().toStdString(),
+                                                                       label->text().toStdString());
+                                if (!mp.isEmpty()) {
+                                    auto mod = ipDesign->getModule();
+                                    if (mod) {
+                                        auto inst        = mp.firstKey();
+                                        auto ifce        = mp[inst];
+                                        auto md          = const_cast<NetSpeed::BDS::Module*>(mod);
+                                        std::string html = md->GetToolTip(inst, ifce);
+                                        QTextEdit* tooltipWindow = new QTextEdit;
+                                        tooltipWindow->setObjectName(OBJ_TOOLTIP_TAB_WIDGET);
+                                        tooltipWindow->setReadOnly(true);
+                                        tooltipWindow->setText(QString::fromStdString(html));
+                                        mw->getInstanceDock()->setWidget(tooltipWindow);
+                                        mw->getInstanceDock()->setWindowTitle("Tooltip");
+                                    }
+                                }
+                            }         
+                        }
+                        
+                        if (_highlightedItem) {
+                            Connector* conn = dynamic_cast<Connector*>(label->parentItem());
+                            if (conn) {
+                                conn->setSelected(true);
+                                _connSelected = conn;
+                                _old_pos = conn->pos();
+                                std::shared_ptr<Node> node = nodeFromConnector(conn);
+                                if (node) {
+                                    _node = node.get();
+                                    _movingNodes = false;
+                                }
+                            }
+                        }
+                    }
+
+                    if (selectedTopLevelItems().size() > 0) {
+                        _movingNodes = true;
+                    }
+                }
+
+                if (_highlightedItem) {
+                    Connector* conn = dynamic_cast<Connector*>(item);
+                    if (conn) {
+                        _connSelected = conn;
+                        _old_pos = conn->pos();
+                        std::shared_ptr<Node> node = nodeFromConnector(conn);
+                        if (node) {
+                            _node = node.get();
+                            _movingNodes = false;
+                        }
+                    }
+                }               
+            } else {
+                _movingNodes = false;
+                if (!event->modifiers().testFlag(Qt::ControlModifier)) {
+                    for (auto const& it : _items) {
+                        if (it->isHighlighting()) {
+                            it->setHighlighted(false);
+                            it->update();
+                            emit it->highlightChanged(*it, false);
+                        }
+                    }
+                    _selectedItems.clear();
+                    emit disableHilightedItems();
+                    auto mw = dynamic_cast<IPMainWindow*>(QApplication::activeWindow());
+                    if (mw) {
+                        auto proper = mw->getPropertyPanel();
+                        if (proper) {
+                            proper->clearAll();
+                        }
+                    }
+                }
+
+                if (event->button() == Qt::LeftButton) {
+                    /* Clear _renderWireList */
+                    for (auto item : _renderWireList) {
+                        removeWire(item);
+                    }
+                    _renderWireList.clear();
+                }
+            }
+
+            // Store the initial position of all the selected items
+            _initialItemPositions.clear();
+            for (auto& item: selectedTopLevelItems()) {
+                if (item) {
+                    _initialItemPositions.insert(item, item->pos());
+                }
+            }
+
+            // Store the initial cursor position
+            _initialCursorPosition = event->scenePos();
+
+            break;
+        }
+
+        case WireMode:
+        {
+
+            // Left mouse button
+            if (event->button() == Qt::LeftButton) {
+
+                // Start a new wire if there isn't already one. Else continue the current one.
+                if (!_newWire) {
+                    _newWire = makeWire();
+                    _newWire->setPos(_settings.snapToGrid(event->scenePos()));
+                    _newWire->setItemType(ItemType::ManualWireType);
+                }
+                // Snap to grid
+            
+
+                auto appendPoint = [&](const QPointF point) {
+                    _newWire->append_point(point);
+                    _newWireSegment = true;
+                };
+                // Attach point to connector if needed
+                bool wireAttached = false;
+                for (const auto& node: nodes()) {
+                    for (const auto& connector: node->connectors()) {
+                        if (connector->sceneBoundingRect().adjusted(-1, -1, 1, 1).contains(event->scenePos())) {
+                            const QPointF& snappedPos = _settings.snapToGrid(connector->scenePos());
+                            appendPoint(snappedPos);
+                            m_wire_manager->attach_wire_to_connector(_newWire.get(), _newWire->pointsAbsolute().indexOf(snappedPos),
+                                                                     connector.get());
+                            wireAttached = true;
+                            break;
+                        }
+                    }
+                }
+
+                if (!wireAttached) appendPoint(_settings.snapToGrid(event->scenePos()));
+            
+                // Attach point to wire if needed
+                for (const auto& wire: m_wire_manager->wires()) {
+                    // Skip current wire
+                    if (wire == _newWire) {
+                        continue;
+                    }
+                    if (wire->point_is_on_wire(_newWire->pointsAbsolute().last())) {
+                        m_wire_manager->connect_wire(wire.get(), _newWire.get(), _newWire->pointsAbsolute().count() - 1);
+                        wireAttached = true;
+                        break;
+                    }
+                }
+
+                // Check if both ends of the wire are connected to something
+                if (wireAttached && _newWire->pointsAbsolute().count() > 1) {
+                    finishCurrentWire();
+                }
+
+            }
+
+            break;
+        }
+    }
+
+    _lastMousePos = event->scenePos();
+}
+
+bool Scene::forceConnectorPos()
+{
+    bool ret = false;
+
+    for (auto& conn : _node->connectors()) {
+        if ((qFuzzyCompare(conn->posX(), _connSelected->posX())) &&
+            (qFuzzyCompare(conn->posY(), _connSelected->posY()))) {
+            if (_connSelected != conn.get()) {
+                _undoStack->push(new CommandConnectorMove(_connSelected, _connSelected->pos(), _old_pos));
+                _connSelected = conn.get();
+                _old_pos = _connSelected->pos();
+                ret = true;
+                break;
+            }
+        }
+    }
+
+    return (ret);
+}
+
+bool Scene::checkPinsOverlap()
+{
+    bool ret = false;
+    
+    for (auto& conn : _node->connectors()) {
+        if ((qFuzzyCompare(conn->posX(), _connSelected->posX())) &&
+            (qFuzzyCompare(conn->posY(), _connSelected->posY()))) {
+            if (_connSelected != conn.get()) {
+                ret = true;
+                break;
+            }
+        }
+    }
+
+    return (ret);
+}
+
+bool Scene::checkPinsEquidistance(int edge) {
+    bool ret = false;
+    int max_node = 0;
+    int x = 0;
+    int y = 0;
+    int grid = _settings.gridSize << 1;
+
+    switch (edge) {
+        case LEFT:
+            max_node = (_node->height() - grid) / grid + 1;
+            y = _node->height() - _settings.gridSize;
+            for (int i = 0; i < max_node; i++) {
+                if (qFuzzyCompare(y, _connSelected->posY())) {
+                    ret = true;
+                }
+                y -= grid;
+            }
+            break;
+
+        case TOP:
+            max_node = (_node->width() - grid) / grid + 1;
+            x = grid;
+            for (int i = 0; i < max_node; i++) {
+                if (qFuzzyCompare(x, _connSelected->posX()) || (_connSelected->posX() <= grid) ||
+                    (_connSelected->posX() > (max_node * grid))) {
+                    ret = true;
+                    break;
+                }
+                x += grid;
+            }
+            break;
+
+        case RIGHT:
+            max_node = (_node->height() - grid) / grid + 1;
+            y = grid + _settings.gridSize;
+            for (int i = 0; i < max_node; i++) {
+                if (qFuzzyCompare(y, _connSelected->posY()) || (_connSelected->posY() <= grid)) {
+                    ret = true;
+                    break;
+                }
+                y += grid;
+            }
+            break;
+
+        case BOTTOM:
+            max_node = (_node->width() - grid) / grid + 1;
+            x = _node->width() - _settings.gridSize;
+            for (int i = 0; i < max_node; i++) {
+                if (qFuzzyCompare(x, _connSelected->posX()) || (_connSelected->posX() <= grid)) {
+                    ret = true;
+                    break;
+                }
+                x -= grid;
+            }
+            break;
+
+        default:
+            /* Do nothing */
+            break;
+    }
+
+    return (ret);
+}
+
+void Scene::checkPinsOverlapLeft()
+{
+    bool ret = false;
+    int max_node = 0;
+    int x = 0;
+    int y = 0;
+    int grid = _settings.gridSize << 1;
+
+    max_node = (_node->height() - grid) / grid;    
+    y = _node->height() - grid - _settings.gridSize;
+    _connSelected->setPosY(y);
+    if (!checkPinsOverlap()) {        
+        y = _node->height() - grid;
+    }
+
+    for (int i = 0; i < max_node; i++) {
+        _connSelected->setPosY(y);
+        if (!checkPinsOverlap()) {
+            ret = true;
+            break;
+        }
+        y -= grid;
+    }
+
+    if (!ret) {
+        /* Enter check Top edge */
+        _connSelected->setPosY(0);
+        max_node = (_node->width() - grid) / grid;
+        x = grid;
+        _connSelected->setPosX(x);
+        if (!checkPinsOverlap()) {
+            x += _settings.gridSize;
+        }
+        for (int i = 0; i < max_node; i++) {
+            _connSelected->setPosX(x);
+            if (!checkPinsOverlap()) {
+                ret = true;
+                break;
+            }
+            x += grid;
+        }
+    }
+      
+    if (!ret) {
+        /* Enter check Right edge */
+        _connSelected->setPosX(_node->width());
+        int h = _node->height();
+        max_node = (h - grid) / grid;
+        y = grid + _settings.gridSize;
+        _connSelected->setPosY(y);
+        if (!checkPinsOverlap()) {
+            y = grid;
+        }
+        for (int i = 0; i < max_node; i++) {
+            _connSelected->setPosY(y);
+            if (!checkPinsOverlap()) {
+                ret = true;
+                break;
+            }
+            y += grid;
+        }
+    }
+
+    if (!ret) {
+        /* Enter check Bottom edge */
+        _connSelected->setPosY(_node->height());
+        int w = _node->width();
+        max_node = (w - grid) / grid;
+        x = w - grid - _settings.gridSize;
+        _connSelected->setPosX(x);
+        if (!checkPinsOverlap()) {
+            x = w - grid;
+        }
+        for (int i = 0; i < max_node; i++) {
+            _connSelected->setPosX(x);
+            if (!checkPinsOverlap()) {
+                ret = true;
+                break;
+            }
+            x -= grid;
+        }
+    }
+}
+
+void Scene::checkPinsOverlapTop()
+{
+    bool ret = false;
+    int max_node = 0;
+    int x = 0;
+    int y = 0;
+    int grid = _settings.gridSize << 1;
+
+    
+    max_node = (_node->width() - grid) / grid;
+
+    x = grid;
+    _connSelected->setPosX(x);
+    if (!checkPinsOverlap()) {
+        x += _settings.gridSize;
+    }
+
+    for (int i = 0; i < max_node; i++) {
+        _connSelected->setPosX(x);
+        if (!checkPinsOverlap()) {
+            ret = true;
+            break;
+        }
+        x += grid;
+    }
+
+    if (!ret) {
+        /* Enter to check Right edge */
+        _connSelected->setPosX(_node->width());
+        int h = _node->height();
+        max_node = (h - grid) / grid;
+        y = grid + _settings.gridSize;
+        _connSelected->setPosY(y);
+        if (!checkPinsOverlap()) {
+            y = grid;
+        }
+        for (int i = 0; i < max_node; i++) {
+            _connSelected->setPosY(y);
+            if (!checkPinsOverlap()) {
+                ret = true;
+                break;
+            }
+            y += grid;
+        }
+    }
+
+    if (!ret) {
+        /* Enter to check Bottom edge */
+        _connSelected->setPosY(_node->height());
+        int w = _node->width();
+        max_node = (w - grid) / grid;
+        x = w - grid - _settings.gridSize;
+        _connSelected->setPosX(x);
+        if (!checkPinsOverlap()) {
+            x = w - grid;
+        }
+        for (int i = 0; i < max_node; i++) {
+            _connSelected->setPosX(x);
+            if (!checkPinsOverlap()) {
+                ret = true;
+                break;
+            }
+            x -= grid;
+        }
+    }
+
+    if (!ret) {
+        /* Enter to check Left edge */
+        _connSelected->setPosX(0);
+        max_node = (_node->height() - grid) / grid;
+        y = _node->height() - grid - _settings.gridSize;
+        _connSelected->setPosY(y);
+        if (!checkPinsOverlap()) {
+            y = _node->height() - grid;
+        }
+        for (int i = 0; i < max_node; i++) {
+            _connSelected->setPosY(y);
+            if (!checkPinsOverlap()) {
+                ret = true;
+                break;
+            }
+            y -= grid;
+        }
+    }
+}
+
+void Scene::checkPinsOverlapRight()
+{
+    bool ret = false;
+    int max_node = 0;
+    int x = 0;
+    int y = 0;
+    int grid = _settings.gridSize << 1;
+   
+    int h = _node->height();
+    max_node = (h - grid) / grid;
+    y = grid + _settings.gridSize;
+    _connSelected->setPosY(y);
+    if (!checkPinsOverlap()) {
+        y = grid;
+    }
+    for (int i = 0; i < max_node; i++) {
+        _connSelected->setPosY(y);
+        if (!checkPinsOverlap()) {
+            ret = true;
+            break;
+        }
+        y += grid;
+    }
+
+    if (!ret) {
+        /* Enter to check Bottom edge */
+        _connSelected->setPosY(_node->height());
+        int w = _node->width();
+        max_node = (w - grid) / grid;
+        x = w - grid - _settings.gridSize;
+        _connSelected->setPosX(x);
+        if (!checkPinsOverlap()) {
+            x = w - grid;
+        }
+        for (int i = 0; i < max_node; i++) {
+            _connSelected->setPosX(x);
+            if (!checkPinsOverlap()) {
+                ret = true;
+                break;
+            }
+            x -= grid;
+        }
+    }
+
+    if (!ret) {
+        /* Enter to check Left edge */
+        _connSelected->setPosX(0);
+        max_node = (_node->height() - grid) / grid;
+        y = _node->height() - grid - _settings.gridSize;
+        _connSelected->setPosY(y);
+        if (!checkPinsOverlap()) {
+            y = _node->height() - grid;
+        }
+        for (int i = 0; i < max_node; i++) {
+            _connSelected->setPosY(y);
+            if (!checkPinsOverlap()) {
+                ret = true;
+                break;
+            }
+            y -= grid;
+        }
+    }
+
+    if (!ret) {
+        /* Enter to check Top edge */
+        max_node = (_node->width() - grid) / grid;
+        x = grid;
+        _connSelected->setPosX(x);
+        if (!checkPinsOverlap()) {
+            x += _settings.gridSize;
+        }
+        for (int i = 0; i < max_node; i++) {
+            _connSelected->setPosX(x);
+            if (!checkPinsOverlap()) {
+                ret = true;
+                break;
+            }
+            x += grid;
+        }
+    }
+}
+
+void Scene::checkPinsOverlapBottom()
+{
+    bool ret = false;
+    int max_node = 0;
+    int x = 0;
+    int y = 0;
+    int grid = _settings.gridSize << 1;
+   
+    int w = _node->width();
+    max_node = (w - grid) / grid;    
+    x = w - grid - _settings.gridSize;
+    _connSelected->setPosX(x);
+    if (!checkPinsOverlap()) {
+        x = w - grid;
+    }
+    for (int i = 0; i < max_node; i++) {
+        _connSelected->setPosX(x);
+        if (!checkPinsOverlap()) {
+            ret = true;
+            break;
+        }
+        x -= grid;
+    }
+
+    if (!ret) {
+        /* Enter to check Left edge */
+        _connSelected->setPosX(0);
+        max_node = (_node->height() - grid) / grid;
+        y = _node->height() - grid - _settings.gridSize;
+        _connSelected->setPosY(y);
+        if (!checkPinsOverlap()) {
+            y = _node->height() - grid;
+        }
+        for (int i = 0; i < max_node; i++) {
+            _connSelected->setPosY(y);
+            if (!checkPinsOverlap()) {
+                ret = true;
+                break;
+            }
+            y -= grid;
+        }
+    }
+
+    if (!ret) {
+        /* Enter to check Top edge */
+        max_node = (_node->width() - grid) / grid;
+        x = grid;
+        _connSelected->setPosX(x);
+        if (!checkPinsOverlap()) {
+            x += 10;
+        }
+        for (int i = 0; i < max_node; i++) {
+            _connSelected->setPosX(x);
+            if (!checkPinsOverlap()) {
+                ret = true;
+                break;
+            }
+            x += grid;
+        }
+    }
+
+    if (!ret) {
+        /* Enter to check Right edge */
+        _connSelected->setPosX(_node->width());
+        int h = _node->height();
+        max_node = (h - grid) / grid;
+        y = grid;
+        _connSelected->setPosY(y);
+        if (!checkPinsOverlap()) {
+            y += 10;
+        }
+        for (int i = 0; i < max_node; i++) {
+            _connSelected->setPosY(y);
+            if (!checkPinsOverlap()) {
+                ret = true;
+                break;
+            }
+            y += grid;
+        }
+    }
+}
+
+
+void Scene::mouseReleaseEvent(QGraphicsSceneMouseEvent* event)
+{
+    event->accept();
+
+    switch (_mode) {
+    case NormalMode:
+    {
+        QGraphicsScene::mouseReleaseEvent(event);
+
+        for (const auto& net : m_wire_manager->nets()) {
+
+            // Make sure it's a WireNet
+            auto wire_net = std::dynamic_pointer_cast<WireNet>(net);
+            if (!wire_net) {
+                continue;
+            }
+
+            wire_net->updateLabelPos(true);
+        }
+        // Reset the position for every selected item and
+        // apply the translation through the undostack
+        if (_movingNodes) {
+            QVector<std::shared_ptr<Item>> wiresToMove;
+            QVector<std::shared_ptr<Item>> itemsToMove;
+
+            for (const auto& item : selectedTopLevelItems()) {
+                if (item->isMovable() && _initialItemPositions.contains(item)) {
+                    Wire* wire = dynamic_cast<Wire*>(item.get());
+                    if (wire) {
+                        wiresToMove << item;
+                    } else {
+                        itemsToMove << item;
+                    }
+                }
+            }
+
+            itemsToMove = wiresToMove << itemsToMove;
+            bool needsToMove = false;
+            QVector<QVector2D> moveByList;
+
+            for (const auto& item : itemsToMove) {
+                // Move the item if it is movable and it was previously registered by the mousePressEvent
+                QVector2D moveBy(item->pos() - _initialItemPositions.value(item));
+                // Move the item to its initial position
+                item->setPos(_initialItemPositions.value(item));
+                // Add the moveBy to the list
+                moveByList << moveBy;
+                if (!moveBy.isNull()) {
+                    needsToMove = true;
+                }
+            }
+            // Apply the translation
+            if (needsToMove) {
+                _undoStack->push(new CommandItemMove(itemsToMove, moveByList));
+            }
+            for (const auto& item : itemsToMove) {
+                const Node* node = dynamic_cast<const Node*>(item.get());
+                if (node) {
+                    updateNodeConnections(node);
+                }
+            }
+
+            for (auto& item : m_wire_manager->wires()) {
+                Wire* wire = dynamic_cast<Wire*>(item.get());
+                if (wire) {
+                    wire->simplify();
+                }
+            }
+        } else {
+            if (_connSelected && _node) {          
+                 if (forceConnectorPos()) {
+                    if (_connSelected->posX() == 0) {                        
+                        checkPinsOverlapLeft(); 
+                    } else if (_connSelected->posY() == 0) {                 
+                        checkPinsOverlapTop(); 
+                    } else if (_connSelected->posX() == _node->width()) {    
+                        checkPinsOverlapRight(); 
+                    } else {                                                    
+                        checkPinsOverlapBottom();  
+                    }
+                 } else {
+                     if (_connSelected->posX() == 0) {
+                         if (checkPinsEquidistance(LEFT)) {
+                             checkPinsOverlapLeft();
+                         }
+                     } else if (_connSelected->posY() == 0) {
+                         if (checkPinsEquidistance(TOP)) {
+                             checkPinsOverlapTop();
+                         }
+                     } else if (_connSelected->posX() == _node->width()) {
+                         if (checkPinsEquidistance(RIGHT)) {
+                             checkPinsOverlapRight();
+                         }
+                     } else {
+                         if (checkPinsEquidistance(BOTTOM)) {
+                             checkPinsOverlapBottom();
+                         }
+                     }
+                 }
+                _undoStack->push(new CommandConnectorMove(_connSelected, _connSelected->pos(), _old_pos));
+            }
+        }
+
+        if (drag) {           
             auto items = selectedItems();
-            if (!items.empty()) {
-                QList<QString> instNames;
-                auto mw = dynamic_cast<IPMainWindow*>(QApplication::activeWindow());
-                IPPropertyPanel* proper = nullptr;
-                if (mw) {
-                    proper = mw->getPropertyPanel();
-                    if (proper) {
-                        proper->drag = true; /* Markek as select multi instance to hanle in IPProertyPanel */
-                    }
-                }
-                for (auto const& it : items) {
-                    auto item = dynamic_cast<IPInstance*>(it.get());
-                    if (item) {
-                        auto instName = item->getinstanceName();
-                        instNames.append(instName);
-                        // Set instance parameters
-                        if (mw) {
-                            mw->updateIntanceParameter(instName);
-                        }
-                        /* Marked higlighted instance */
-                        if (!_selectedItems.contains(it.get())) {
-                            it->setHighlighted(true);
-                            itemHoverEnter(it->shared_from_this());
-                            it->update();
-                            emit item->highlightChanged(*it, true);
-                            _selectedItems.push_back(it.get());
-                        }
-                    }
-                }
-
-                if (!instNames.isEmpty()) {
-                    // highlight QTreeWidget
-                    emit setSelectedItems(instNames);
-                }
-
-                if (proper) {
-                    proper->drag = false;
-                }
-                _highlightedItem = nullptr;
-            }
-            drag = false;
-        }
-
-        break;
-    }
-
-    case WireMode:
-    {
-        // Right mouse button: Abort wire mode
-        if (event->button() == Qt::RightButton) {
-
-            // Change the mode back to NormalMode if nothing below cursor
-            if (QGraphicsScene::items(event->scenePos()).isEmpty()) {
-                setMode(NormalMode);
-            }
-
-            // Show the context menu stuff
-            QGraphicsScene::mouseReleaseEvent(event);
-        }
-
-        break;
-    }
-    }
-
-    _lastMousePos = event->lastScenePos();
-}
-
-void Scene::updateNodeConnections(const Node* node) const
-{
-    // Check if a connector lays on a wirepoint
-    for (auto& connector : node->connectors()) {
-        // If the connector already has a wire attached, skip
-        if (m_wire_manager->attached_wire(connector.get()) != nullptr) {
-            continue;
-        }
-        // Find if there is a point to connect to
-        for (const auto& wire : m_wire_manager->wires()) {
-            int index = -1;
-            if (wire->points().first().toPoint() == connector->scenePos().toPoint()) {
-                index = 0;
-            } else if (wire->points().last().toPoint() == connector->scenePos().toPoint()) {
-                index = wire->points().count() - 1;
-            }
-            if (index != -1) {
-                // Ignore if it's a junction
-                if (wire->points().at(index).is_junction()){
-                    continue;
-                }
-                // Check if it isn't already connected to another connector
-                bool alreadyConnected = false;
-                for (const auto& otherConnector : connectors()) {
-                    if (otherConnector == connector) {
-                        continue;
-                    }
-                    if (m_wire_manager->attached_wire(connector.get()) == wire.get() &&
-                        m_wire_manager->attached_point(otherConnector.get()) == index) {
-                        alreadyConnected = true;
-                        break;
-                    }
-                }
-                // If it's not already connected, connect it
-                if (!alreadyConnected) {
-                    m_wire_manager->attach_wire_to_connector(wire.get(), index, connector.get());
-                }
-            }
-        }
-    }
-}
-
-void Scene::wirePointMoved(wire& rawWire, int index)
-{
-    // Detach from connector
-    for (const auto& node: nodes()) {
-        for (const auto& connector: node->connectors()) {
-            const wire* wire = m_wire_manager->attached_wire(connector.get());
-            if (!wire) {
-                continue;
-            }
-
-            if (wire != &rawWire) {
-                continue;
-            }
-
-            if (m_wire_manager->attached_point(connector.get()) == index) {
-                if (connector->scenePos().toPoint() != rawWire.points().at(index).toPoint()) {
-                    m_wire_manager->detach_wire(connector.get());
-                }
-            }
-        }
-    }
-
-    // Attach to connector
-    point point = rawWire.points().at(index);
-    for (const auto& node: nodes()) {
-        for (const auto& connector: node->connectors()) {
-            if (connector->scenePos().toPoint() == point.toPoint()) {
-                m_wire_manager->attach_wire_to_connector(&rawWire, index, connector.get());
-            }
-        }
-    }
-}
-
-void Scene::mouseMoveEvent(QGraphicsSceneMouseEvent* event)
-{
-    event->accept();
-
-    // Retrieve the new mouse position
-    QPointF newMousePos = event->scenePos();
-
-    switch (_mode) {
-
-    case NormalMode:
-    {
-        // Let the base class handle the basic stuff
-        // Note that we DO NOT want this in WireMode to prevent highlighting of the wires
-        // during placing a new wire.
-
-        // Move, resize or rotate if supposed to
-        if (event->buttons() & Qt::LeftButton) {
-            // Move all selected items
-            if (_movingNodes) {
-                QVector<std::shared_ptr<Item>> wiresToMove;
-                QVector<std::shared_ptr<Item>> itemsToMove;
-                for (const auto& item : selectedTopLevelItems()) {
-                    if (item->isMovable()) {
-                        Wire* wire = dynamic_cast<Wire*>(item.get());
-                        if (wire) {
-                            wiresToMove << item;
-                        } else {
-                            itemsToMove << item;
-                        }
-                    }
-                }
-                itemsToMove = wiresToMove << itemsToMove;
-                for (const auto& item : itemsToMove) {
-                    // Calculate by how much the item was moved
-                    QPointF moveBy = _initialItemPositions.value(item) + newMousePos - _initialCursorPosition - item->pos();
-                    // Apply the custom scene snapping
-                    moveBy = itemsMoveSnap(item, QVector2D(moveBy)).toPointF();
-                    item->setPos(item->pos() + moveBy);
-                }
-                // Simplify all the wires
-                for (auto& wire : m_wire_manager->wires()) {
-                    wire->simplify();
-                }
-            }
-            else {
-                QGraphicsScene::mouseMoveEvent(event);
-            }
-
-            drag = true; /* Select multi instances */        
-        } else {
-            QGraphicsScene::mouseMoveEvent(event);
-        }
-
-        // Highlight the item under the cursor       
-        Item* item = dynamic_cast<Item*>(itemAt(newMousePos, QTransform()));
-        if (item) {
-            // Skip if the item is already highlighted
-            if (item == _highlightedItem) {
-                break;
-            }
-
-            // Disable the highlighting on the previous item
-            if (_highlightedItem) {
-                if (!event->modifiers().testFlag(Qt::ControlModifier)) {
-                    if (!_selectedItems.contains(_highlightedItem)) {
-                        _highlightedItem->setHighlighted(false);
-                        itemHoverLeave(_highlightedItem->shared_from_this());
-                        _highlightedItem->update();
-                        emit _highlightedItem->highlightChanged(*_highlightedItem, false);
-                    }
-                }
-                _highlightedItem = nullptr;
-
-                if (flag) {
-                    flag = false;
-
-                    /* Remove wires*/
-                    for (auto& it : _highlightedList.first) {
-                        removeWire(it);
-                    }
-
-                    /* Disable highlighted */
-                    for (auto& it : _highlightedList.second) {
-                        it->setHighlighted(false);
-                    }  
-                }
-            }
-            if (!(event->buttons() & Qt::LeftButton)) {
-                if (!event->modifiers().testFlag(Qt::ControlModifier)) {
-                    if (!item->isHighlighting()) {
-                        Label* label = dynamic_cast<Label*>(item);
-                        auto mw = dynamic_cast<IPMainWindow*>(QApplication::activeWindow());
-                        if (label && mw) {
-                            auto ipconn = dynamic_cast<IPConnectivity*>(label->parentItem());
-                            if (ipconn) {
-                                auto ipDesign = mw->getIPDesign();
-                                if (ipDesign) {
-                                    auto mp =
-                                        ipDesign->findInstanceAndInterface(ipconn->getInstanceName().toStdString(),
-                                                                           label->text().toStdString());
-                                    if (!mp.isEmpty()) {
-                                        auto mod = ipDesign->getModule();
-                                        if (mod) {
-                                            auto inst = mp.firstKey();
-                                            auto ifce = mp[inst];
-                                            auto md   = const_cast<NetSpeed::BDS::Module*>(mod);
-                                            std::string html = "<span style='font-size:10pt';>" + md->GetToolTip(inst, ifce) + "</span>";
-                                            item->setToolTip(QString::fromStdString(html));
-                                        }
-                                    }
-                                }
-                            }
-                        }
-                        // Highlight the item
-                        item->setHighlighted(true);
-                        itemHoverEnter(item->shared_from_this());
-                        item->update();
-                        emit item->highlightChanged(*item, true);
-                    }
-                } 
-                _highlightedItem = item;
-
-                IPConnectivity* ipconn = dynamic_cast<IPConnectivity*>(item->parentItem());
-                auto lb = dynamic_cast<Label*>(item);
-                if (ipconn && lb) {
-                    /* Show connectivity net of interface */
-                    auto mw = dynamic_cast<IPMainWindow*>(QApplication::activeWindow());
-                    if (mw) {
-                        QList<QString> ifce_name = {lb->text()};
-                        _highlightedList = mw->getIPDesign()->highlightWires(ipconn->getInstanceName(), ifce_name);
-                        flag = true;
-                    }
-                }
-            }
-        }
-        // No item selected
-        else if (_highlightedItem) {
-            if (!event->modifiers().testFlag(Qt::ControlModifier)) {
-                if (!_selectedItems.contains(_highlightedItem)) {
-                    _highlightedItem->setHighlighted(false);
-                    _highlightedItem->update();
-                    emit _highlightedItem->highlightChanged(*_highlightedItem, false);
-                }
-                _highlightedItem = nullptr;
-            }
-            
-            if (flag) {
-                flag = false;
-
-                /* Remove wires*/
-                for (auto& it : _highlightedList.first) {
-                    removeWire(it);
-                }
-
-                /* Disable highlighted */
-                for (auto& it : _highlightedList.second) {
-                    it->setHighlighted(false);
-                }                                             
-            }
-        }
-
-        break;
-    }
-
-    case WireMode:
-    {
-        // Make sure that there's a wire
-        if (!_newWire) {
-            break;
-        }
-
-        // Transform mouse coordinates to grid positions (snapped to nearest grid point)
-        const QPointF& snappedPos = _settings.snapToGrid(event->scenePos());
-
-        // Add a new wire segment. Only allow straight angles (if supposed to)
-        if (_settings.routeStraightAngles) {
-            if (_newWireSegment) {
-                // Remove the last point if there was a previous segment
-                if (_newWire->pointsRelative().count() > 1) {
-                    _newWire->removeLastPoint();
-                }
-
-                // Create the intermediate point that creates the straight angle
-                point prevNode(_newWire->pointsAbsolute().at(_newWire->pointsAbsolute().count() - 1));
-                QPointF corner(prevNode.x(), snappedPos.y());
-                if (_invertWirePosture) {
-                    corner.setX(snappedPos.x());
-                    corner.setY(prevNode.y());
-                }
-
-                // Add the two new points
-                _newWire->append_point(corner);
-                _newWire->append_point(snappedPos);
-
-                _newWireSegment = false;
-            } else {
-                // Create the intermediate point that creates the straight angle
-                point p1(_newWire->pointsAbsolute().at(_newWire->pointsAbsolute().count() - 3));
-                QPointF p2(p1.x(), snappedPos.y());
-                QPointF p3(snappedPos);
-                if (_invertWirePosture) {
-                    p2.setX(p3.x());
-                    p2.setY(p1.y());
-                }
-
-                // Modify the actual wire
-                _newWire->move_point_to(_newWire->pointsAbsolute().count() - 2, p2);
-                _newWire->move_point_to(_newWire->pointsAbsolute().count() - 1, p3);
-            }
-        } else {
-            // Don't care about angles and stuff. Fuck geometry, right?
-            if (_newWire->pointsAbsolute().count() > 1) {
-                _newWire->move_point_to(_newWire->pointsAbsolute().count() - 1, snappedPos);
-            } else {
-                _newWire->append_point(snappedPos);
-            }
-        }
-
-        break;
-    }
-
-    }
-
-    // Save the last mouse position
-    _lastMousePos = newMousePos;
-}
-
-void Scene::mouseDoubleClickEvent(QGraphicsSceneMouseEvent* event)
-{
-    event->accept();
-
-    switch (_mode) {
-        case NormalMode:
-        {
-            //QPointF newMousePos = event->scenePos();
-            //Item* selectedItem = dynamic_cast<Item*>(itemAt(newMousePos, QTransform()));
-            //QRectF rec = selectedItem->gridRectF();
-
-            QGraphicsScene::mouseDoubleClickEvent(event);
-            return;
-        }
-
-        case WireMode:
-        {
-
-            // Only do something if there's a wire
-            if (_newWire && _newWire->pointsRelative().count() > 1) {
-
-                // Get rid of the last point as mouseDoubleClickEvent() is following mousePressEvent()
-                _newWire->removeLastPoint();
-
-                // Attach point to wire if needed
-                for (const auto& wire: m_wire_manager->wires()) {
-                    // Skip current wire
-                    if (wire == _newWire) {
-                        continue;
-                    }
-                    if (wire->point_is_on_wire(_newWire->pointsAbsolute().last())) {
-                        m_wire_manager->connect_wire(wire.get(), _newWire.get(), _newWire->pointsAbsolute().count() - 1);
-                    }
-                }
-
-                // Finish the current wire
-                finishCurrentWire();
-
-                return;
-            }
-
-            return;
-        }
-    }
-}
-
-void Scene::dragEnterEvent(QGraphicsSceneDragDropEvent* event)
-{
-    // Create a list of mime formats we can handle
-    QStringList mimeFormatsWeCanHandle {
-        MIME_TYPE_NODE,
-    };
-
-    // Check whether we can handle this drag/drop
-    for (const QString& format : mimeFormatsWeCanHandle) {
-        if (event->mimeData()->hasFormat(format)) {
-            clearSelection();
-            event->acceptProposedAction();
-            return;
-        }
-    }
-
-    event->ignore();
-}
-
-void Scene::dragMoveEvent(QGraphicsSceneDragDropEvent* event)
-{
-    event->acceptProposedAction();
-}
-
-void Scene::dragLeaveEvent(QGraphicsSceneDragDropEvent* event)
-{
-    event->acceptProposedAction();
-}
-
-void Scene::dropEvent(QGraphicsSceneDragDropEvent* event)
-{
-    event->accept();
-
-    // Check the mime data
-    const QMimeData* mimeData = event->mimeData();
-    if (!mimeData) {
-        return;
-    }
-
-    // Nodes
-    if (mimeData->hasFormat(MIME_TYPE_NODE)) {
-        // Get the ItemMimeData
-        const ItemMimeData* mimeData = qobject_cast<const ItemMimeData*>(event->mimeData());
-        if (!mimeData) {
-            return;
-        }
-
-        // Get the Item
-        auto item = mimeData->item();
-        if (!item) {
-            return;
-        }
-
-        // Add to the scene
-        item->setPos(event->scenePos());
-        _undoStack->push(new CommandItemAdd(this, std::move(item)));
-    }
-}
-
-void Scene::drawBackground(QPainter* painter, const QRectF& rect)
-{
-   painter->fillRect(rect, Qt::white);
-}
-
-QVector2D Scene::itemsMoveSnap(const std::shared_ptr<Item>& items, const QVector2D& moveBy) const
-{
-    Q_UNUSED(items);
-
-    return moveBy;
-}
-
-void Scene::renderCachedBackground()
-{
-    // Create the pixmap
-    QRect rect = sceneRect().toRect();
-    if (rect.isNull() || !rect.isValid()) {
-        return;
-    }
-    QPixmap pixmap(rect.width(), rect.height());
-
-    // Grid pen
-    QPen gridPen;
-    gridPen.setStyle(Qt::SolidLine);
-    gridPen.setColor(Qt::gray);
-    gridPen.setCapStyle(Qt::RoundCap);
-    gridPen.setWidth(_settings.gridPointSize);
-
-    // Grid brush
-    QBrush gridBrush;
-    gridBrush.setStyle(Qt::NoBrush);
-
-    // Create a painter
-    QPainter painter(&pixmap);
-    painter.setBrush(Qt::black);
-    painter.setRenderHint(QPainter::Antialiasing, _settings.antialiasing);
-
-    // Draw background
-    pixmap.fill(Qt::white);
-
-    // Draw the grid if supposed to
-    if (_settings.showGrid && (_settings.gridSize > 0)) {
-        qreal left = int(rect.left()) - (int(rect.left()) % _settings.gridSize);
-        qreal top = int(rect.top()) - (int(rect.top()) % _settings.gridSize);
-
-        // Create a list of points
-        QVector<QPointF> points;
-        for (qreal x = left; x < rect.right(); x += _settings.gridSize) {
-            for (qreal y = top; y < rect.bottom(); y += _settings.gridSize) {
-                points.append(QPointF(x,y));
-            }
-        }
-
-        // Draw the actual grid points
-        painter.setPen(gridPen);
-        painter.setBrush(gridBrush);
-        painter.drawPoints(points.data(), points.size());
-    }
-
-    // Mark the origin if supposed to
-    if (_settings.debug) {
-        painter.setPen(Qt::NoPen);
-        painter.setBrush(Qt::red);
-        painter.drawEllipse(-6, -6, 12, 12);
-    }
-
-    painter.end();
-
-    // Update
-    _backgroundPixmap = pixmap;
-    update();
-}
-
-void Scene::setupNewItem(Item& item)
-{
-    // Set settings
-    item.setSettings(_settings);
-}
-
-void Scene::generateConnections()
-{
-    for (const auto& connector : connectors()) {
-        std::shared_ptr<wire> wire = m_wire_manager->wire_with_extremity_at(connector->scenePos());
-        if (wire) {
-            m_wire_manager->attach_wire_to_connector(wire.get(), connector.get());
-        }
-    }
-}
-
-/**
- * Finishes the current wire if there is one
- */
-void Scene::finishCurrentWire()
-{
-    if (!_newWire) {
-        return;
-    }
-    // Finish the current wire
-    _newWire->setAcceptHoverEvents(true);
-    _newWire->setFlag(QGraphicsItem::ItemIsSelectable, true);
-    _newWire->simplify();
-//    _newWire->updatePosition();
-    _newWire.reset();
-}
-
-
-QList<QPointF> Scene::connectionPoints() const
-{
-    QList<QPointF> list;
-
-    for (const auto& node : nodes()) {
-        list << node->connectionPointsAbsolute();
-    }
-
-    return list;
-}
-
-QList<std::shared_ptr<Connector>> Scene::connectors() const
-{
-    QList<std::shared_ptr<Connector>> list;
-
-    for (const auto& node : nodes()) {
-        list << node->connectors();
-    }
-
-    return list;
-}
-
-void Scene::itemHoverEnter(const std::shared_ptr<const Item>& item)
-{
-    emit itemHighlighted(item);
-}
-
-void Scene::itemHoverLeave(const std::shared_ptr<const Item>& /*item*/)
-{
-    emit itemHighlighted(nullptr);
-}
-
-/**
- * Removes the last point(s) of the new wire. After execution, the wire should
- * be in the same state it was before the last point had been added.
- */
-void Scene::removeLastWirePoint()
-{
-    if (!_newWire) {
-        return;
-    }
-
-    // If we're supposed to preseve right angles, two points have to be removed
-    if (_settings.routeStraightAngles) {
-        // Do nothing if there are not at least 4 points
-        if (_newWire->pointsAbsolute().count() > 3) {
-            // Keep the position of the last point
-            QPointF mousePos = _newWire->pointsAbsolute().last();
-            // Remove both points
-            _newWire->removeLastPoint();
-            _newWire->removeLastPoint();
-            // Move the new last point to where the previous last point was
-            _newWire->move_point_by(_newWire->pointsAbsolute().count() - 1,
-                                    QVector2D(mousePos - _newWire->pointsAbsolute().last()));
-        }
-    }
-
-    // If we don't care about the angles, only the last point has to be removed
-    else {
-        // Do nothing if there are not at least 3 points
-        if (_newWire->pointsAbsolute().count() > 2) {
-            // Keep the position of the last point
-            QPointF mousePos = _newWire->pointsAbsolute().last();
-            // Remove the point
-            _newWire->removeLastPoint();
-            // Move the new last point to where the previous last point was
-            _newWire->move_point_to(_newWire->pointsAbsolute().count() - 1, mousePos);
-        }
-    }
-}
-
-/**
- * Removes the wires and wire nets that are not connected to a node
- */
-void Scene::removeUnconnectedWires()
-{
-    QList<std::shared_ptr<Wire>> wiresToRemove;
-
-    for (const auto& wire : m_wire_manager->wires()) {
-        // If it has wires attached to it, go to the next wire
-        if (wire->connected_wires().count() > 0) {
-            continue;
-        }
-
-        bool isConnected = false;
-
-        // Check if it is connected to a wire
-        for (const auto& otherWire : m_wire_manager->wires()) {
-            if (otherWire->connected_wires().contains(wire.get())) {
-                isConnected = true;
-                break;
-            }
-        }
-
-        // If it's connected to a wire, go to the next wire
-        if (isConnected) {
-            continue;
-        }
-
-        // Find out if it's attached to a node
-        for (const auto& connector : connectors()) {
-            if (m_wire_manager->attached_wire(connector.get()) == wire.get()) {
-                isConnected = true;
-                break;
-            }
-        }
-
-        // If it's connected to a connector, go to the next wire
-        if (isConnected) {
-            continue;
-        }
-
-        // The wire has to be removed, add it to the list
-        if (auto wireItem = std::dynamic_pointer_cast<Wire>(wire)) {
-            wiresToRemove << wireItem;
-        }
-    }
-
-    // Remove the wires that have to be removed
-    for (const auto& wire : wiresToRemove) {
-        _undoStack->push(new CommandItemRemove(this, wire));
-    }
-}
-
-bool Scene::addWire(const std::shared_ptr<Wire>& wire)
-{
-    if (!m_wire_manager->add_wire(wire)) {
-        return false;
-    }
-
-    wire->set_manager(m_wire_manager.get());
-
-    // Add wire to scene
-    // Wires created by mouse interactions are already added to the scene in the Scene::mouseXxxEvent() calls. Prevent
-    // adding an already added item to the scene
-    if (wire->scene() != this) {
-        if (!addItem(wire)) {
-            return false;
-        }
-    }
-    return true;
-}
-
-bool Scene::removeWire(const std::shared_ptr<Wire>& wire)
-{
-    // Remove the wire from the scene
-    removeItem(wire);
-
-    // Disconnect from connectors
-    for (const auto& connector: connectors()) {
-        if (m_wire_manager->attached_wire(connector.get()) == wire.get()) {
-            m_wire_manager->detach_wire(connector.get());
-        }
-    }
-
-    return m_wire_manager->remove_wire(wire);
-}
-
-void Scene::closeLayout()
-{
-    clear();
-    emit clearPropertyPanel();
-    emit clearMainConsole();
-}
-
-void Scene::saveLayoutAs(QString filename, QWidget* parent)
-{
-    if (filename.isEmpty()) {
-        /* Do nothing in this case */
-        return;
-    }
-    fileName = filename;
-    /* Put all single QJsonObject objects to an independent one. */
-    QJsonObject content = QJsonObject();            /* Empty obj */
-    QJsonObject obj = QJsonObject();                /* Empty obj */
-    QJsonArray arr = QJsonArray();                  /* Empty arr */
-    QJsonObject pinsCoordinates = QJsonObject();    /* Empty pinsCoordinates */
-    QString proj_name = "Untitled";
-    content.insert(QString("Signature"), QString("IPStudio"));
-
-    /* Get config values*/
-    IPMainWindow* mw = dynamic_cast<IPMainWindow*>(parent);
-    if (mw) {
-        proj_name = mw->getProjectName();
-        content.insert(QString("project_name"), proj_name);
-        QString moduleFile = mw->getModuleFile();
-        QString archFile = mw->getArchFile();
-        auto cfg = QJsonObject();
-        for (const auto& it : mw->mp) {          
-            cfg.insert(QString::fromStdString(it.first), QString::fromStdString(it.second).toInt());
-        }
-        QFileInfo f(moduleFile);
-        obj.insert("moduleFile", f.fileName());
-        f.setFile(archFile);
-        obj.insert("archFile", f.fileName());
-        obj.insert("projName", mw->getProjectName());
-        obj.insert("constraint", cfg);
-    }
-    content.insert(QString("config"), obj);
-         
-    for (auto& item : _items) {       
-        IPInstance* ins = dynamic_cast<IPInstance*>(item.get());
-        if (ins) {
-            obj = QJsonObject(); /* Clear obj */
-            obj.insert("moduleName", QJsonValue(ins->getModuleName()));
-            obj.insert("instanceName", QJsonValue(ins->getinstanceName()));
-            obj.insert("posX", QJsonValue(item->posX()));
-            obj.insert("posY", QJsonValue(item->posY()));
-            obj.insert("scale", QJsonValue(item->scale()));
-            obj.insert("rotation", QJsonValue(item->rotation()));
-            obj.insert("transformOriginPointX", QJsonValue(item->transformOriginPoint().x()));
-            obj.insert("transformOriginPointY", QJsonValue(item->transformOriginPoint().y()));
-            obj.insert("isEnabled", QJsonValue(item->isEnabled()));
-            obj.insert("isSelected", QJsonValue(item->isSelected()));
-            obj.insert("zValue", QJsonValue(item->zValue()));
-            const Node* node = dynamic_cast<Node*>(item.get());
-            if (node) {
-                pinsCoordinates = QJsonObject();
-                for (const auto& conn : node->connectors()) {
-                    auto objPins = QJsonObject();
-                    QString pinName = conn->text();
-                    objPins.insert("x", QJsonValue(conn->posX()));
-                    objPins.insert("y", QJsonValue(conn->posY()));
-                    pinsCoordinates.insert(pinName, objPins);
-                }
-                obj.insert(QString("pinsCoordinates"), pinsCoordinates);
-            }                     
-            arr.push_back(obj);
-        }
-    }
-    content.insert(QString("existItems"), arr);
-
-    /* Create new file to storage all info */
-    QJsonDocument document;
-    document.setObject(content);
-    QByteArray bytes = document.toJson(QJsonDocument::Indented);
-    QFile file(fileName);
-    if (file.open(QIODevice::WriteOnly | QIODevice::Text | QIODevice::Truncate)) {
-        QTextStream iStream(&file);
-        iStream.setEncoding(QStringConverter::Utf8);
-        iStream << bytes;
-        file.close();
-    } 
-}
-
-void Scene::updateLayout(QList<itemProperty> vtItemProperty, QList<QString> lsItemDeleted)
-{
-    /* Deleted item if any */
-    for (auto const& it : lsItemDeleted) {
-        for (auto& item : _items) {
-            IPInstance* ins = dynamic_cast<IPInstance*>(item.get());
-            if (ins) {
-                if (it == ins->getModuleName()) {
-                    removeItem(item);
-                    break;
-                }
-            }
-        }
-    }
-
-    if (vtItemProperty.size() > 0) {
-        int i = 0;
-        for (auto& item : _items) {
-            item->setPos(vtItemProperty.at(i).pos);
-            item->setScale(vtItemProperty.at(i).scale);
-            item->setRotation(vtItemProperty.at(i).rotation);
-            item->setTransformOriginPoint(vtItemProperty.at(i).transformOriginPoint);
-            item->setEnabled(vtItemProperty.at(i).isEnabled);
-            item->setSelected(vtItemProperty.at(i).isSelected);
-            item->setZValue(vtItemProperty.at(i).zValue);
-
-            Node* node = dynamic_cast<Node*>(item.get());
-            if (node && (i < vtItemProperty.size())) {
-                QList<QPair<QString, QPointF>> pinList = vtItemProperty.at(i).pin;
-                for (auto& conn : node->connectors()) {                   
-                    for (auto& pin : pinList) {
-                        QString pinName = pin.first;
-                        QPointF pf(pin.second);
-                        if (pinName.indexOf(conn->text()) != -1) {
-                            /* Update position */
-                            conn->setPos(pf);
-                            pinList.removeOne(pin);
-                            break;
-                        }                        
-                    }
-                }
-                node->alignConnectorLabels();
-            }
-            i++;
-        }
-    }
-}
+            auto mw = dynamic_cast<IPMainWindow*>(QApplication::activeWindow());
+            if (!items.empty()) {
+                QList<QString> instNames;
+                IPPropertyPanel* proper = nullptr;
+                if (mw) {
+                    proper = mw->getPropertyPanel();
+                    if (proper) {
+                        proper->drag = true; /* Markek as select multi instance to hanle in IPProertyPanel */
+                    }
+                }
+                for (auto const& it : items) {
+                    auto item = dynamic_cast<IPInstance*>(it.get());
+                    if (item) {
+                        auto instName = item->getinstanceName();
+                        instNames.append(instName);
+                        // Set instance parameters
+                        if (mw) {
+                            mw->updateIntanceParameter(instName);
+                        }
+                        /* Marked higlighted instance */
+                        if (!_selectedItems.contains(it.get())) {
+                            it->setHighlighted(true);
+                            itemHoverEnter(it->shared_from_this());
+                            it->update();
+                            emit item->highlightChanged(*it, true);
+                            _selectedItems.push_back(it.get());
+                        }
+                    }
+                }
+
+                if (!instNames.isEmpty()) {
+                    // Highlight QTreeWidget
+                    emit setSelectedItems(instNames);
+                }
+
+                if (proper) {
+                    proper->drag = false;
+                }
+                _highlightedItem = nullptr;
+            }
+            drag = false;
+            if (mw) mw->getIPDesign()->refreshWires();
+        }
+
+        break;
+    }
+
+    case WireMode:
+    {
+        // Right mouse button: Abort wire mode
+        if (event->button() == Qt::RightButton) {
+
+            // Change the mode back to NormalMode if nothing below cursor
+            if (QGraphicsScene::items(event->scenePos()).isEmpty()) {
+                setMode(NormalMode);
+            }
+
+            // Show the context menu stuff
+            QGraphicsScene::mouseReleaseEvent(event);
+        }
+
+        break;
+    }
+    }
+
+    _lastMousePos = event->lastScenePos();
+}
+
+void Scene::updateNodeConnections(const Node* node) const
+{
+    // Check if a connector lays on a wirepoint
+    for (auto& connector : node->connectors()) {
+        // If the connector already has a wire attached, skip
+        if (m_wire_manager->attached_wire(connector.get()) != nullptr) {
+            continue;
+        }
+        // Find if there is a point to connect to
+        for (const auto& wire : m_wire_manager->wires()) {
+            int index = -1;
+            if (wire->points().first().toPoint() == connector->scenePos().toPoint()) {
+                index = 0;
+            } else if (wire->points().last().toPoint() == connector->scenePos().toPoint()) {
+                index = wire->points().count() - 1;
+            }
+            if (index != -1) {
+                // Ignore if it's a junction
+                if (wire->points().at(index).is_junction()){
+                    continue;
+                }
+                // Check if it isn't already connected to another connector
+                bool alreadyConnected = false;
+                for (const auto& otherConnector : connectors()) {
+                    if (otherConnector == connector) {
+                        continue;
+                    }
+                    if (m_wire_manager->attached_wire(connector.get()) == wire.get() &&
+                        m_wire_manager->attached_point(otherConnector.get()) == index) {
+                        alreadyConnected = true;
+                        break;
+                    }
+                }
+                // If it's not already connected, connect it
+                if (!alreadyConnected) {
+                    m_wire_manager->attach_wire_to_connector(wire.get(), index, connector.get());
+                }
+            }
+        }
+    }
+}
+
+void Scene::wirePointMoved(wire& rawWire, int index)
+{
+    // Detach from connector
+    for (const auto& node: nodes()) {
+        for (const auto& connector: node->connectors()) {
+            const wire* wire = m_wire_manager->attached_wire(connector.get());
+            if (!wire) {
+                continue;
+            }
+
+            if (wire != &rawWire) {
+                continue;
+            }
+
+            if (m_wire_manager->attached_point(connector.get()) == index) {
+                if (connector->scenePos().toPoint() != rawWire.points().at(index).toPoint()) {
+                    m_wire_manager->detach_wire(connector.get());
+                }
+            }
+        }
+    }
+
+    // Attach to connector
+    point point = rawWire.points().at(index);
+    for (const auto& node: nodes()) {
+        for (const auto& connector: node->connectors()) {
+            if (connector->scenePos().toPoint() == point.toPoint()) {
+                m_wire_manager->attach_wire_to_connector(&rawWire, index, connector.get());
+            }
+        }
+    }
+}
+
+void Scene::mouseMoveEvent(QGraphicsSceneMouseEvent* event)
+{
+    event->accept();
+
+    // Retrieve the new mouse position
+    QPointF newMousePos = event->scenePos();
+
+    switch (_mode) {
+
+    case NormalMode:
+    {
+        // Let the base class handle the basic stuff
+        // Note that we DO NOT want this in WireMode to prevent highlighting of the wires
+        // during placing a new wire.
+
+        // Move, resize or rotate if supposed to
+        if (event->buttons() & Qt::LeftButton) {
+            // Move all selected items
+            if (_movingNodes) {
+                QVector<std::shared_ptr<Item>> wiresToMove;
+                QVector<std::shared_ptr<Item>> itemsToMove;
+                for (const auto& item : selectedTopLevelItems()) {
+                    if (item->isMovable()) {
+                        Wire* wire = dynamic_cast<Wire*>(item.get());
+                        if (wire) {
+                            wiresToMove << item;
+                        } else {
+                            itemsToMove << item;
+                        }
+                    }
+                }
+                itemsToMove = wiresToMove << itemsToMove;
+                for (const auto& item : itemsToMove) {
+                    // Calculate by how much the item was moved
+                    QPointF moveBy = _initialItemPositions.value(item) + newMousePos - _initialCursorPosition - item->pos();
+                    // Apply the custom scene snapping
+                    moveBy = itemsMoveSnap(item, QVector2D(moveBy)).toPointF();
+                    item->setPos(item->pos() + moveBy);
+                    auto parentItem = dynamic_cast<IPInstance*>(item->parentItem());
+                    if (parentItem) {
+                        parentItem->update();
+                    }
+                }
+                // Simplify all the wires
+                for (auto& wire : m_wire_manager->wires()) {
+                    wire->simplify();
+                }
+            }
+            else {
+                QGraphicsScene::mouseMoveEvent(event);
+            }
+
+            drag = true; /* Select multi instances */        
+        } else {
+            QGraphicsScene::mouseMoveEvent(event);
+        }
+
+        // Highlight the item under the cursor       
+        Item* item = dynamic_cast<Item*>(itemAt(newMousePos, QTransform()));
+        if (item) {
+            // Skip if the item is already highlighted
+            if (item == _highlightedItem) {
+                break;
+            }
+
+            // Disable the highlighting on the previous item
+            if (_highlightedItem) {
+                if (!event->modifiers().testFlag(Qt::ControlModifier)) {
+                    if (!_selectedItems.contains(_highlightedItem)) {
+                        _highlightedItem->setHighlighted(false);
+                        itemHoverLeave(_highlightedItem->shared_from_this());
+                        _highlightedItem->update();
+                        emit _highlightedItem->highlightChanged(*_highlightedItem, false);
+                    }
+                }
+                _highlightedItem = nullptr;
+
+                if (flag) {
+                    flag = false;
+
+                    /* Remove wires*/
+                    for (auto& it : _highlightedList.first) {
+                        removeWire(it);
+                    }
+
+                    /* Disable highlighted */
+                    for (auto& it : _highlightedList.second) {
+                        it->setHighlighted(false);
+                    }  
+                }
+            }
+            if (!(event->buttons() & Qt::LeftButton)) {
+                if (!event->modifiers().testFlag(Qt::ControlModifier)) {
+                    if (!item->isHighlighting()) {
+                        Label* label = dynamic_cast<Label*>(item);
+                        auto mw = dynamic_cast<IPMainWindow*>(QApplication::activeWindow());
+                        if (label && mw) {
+                            auto ipconn = dynamic_cast<IPConnectivity*>(label->parentItem());
+                            if (ipconn) {
+                                auto ipDesign = mw->getIPDesign();
+                                if (ipDesign) {
+                                    auto mp =
+                                        ipDesign->findInstanceAndInterface(ipconn->getInstanceName().toStdString(),
+                                                                           label->text().toStdString());
+                                    if (!mp.isEmpty()) {
+                                        auto mod = ipDesign->getModule();
+                                        if (mod) {
+                                            auto inst = mp.firstKey();
+                                            auto ifce = mp[inst];
+                                            auto md   = const_cast<NetSpeed::BDS::Module*>(mod);
+                                            std::string html = "<span style='font-size:10pt';>" + md->GetToolTip(inst, ifce) + "</span>";
+                                            item->setToolTip(QString::fromStdString(html));
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                        // Highlight the item
+                        item->setHighlighted(true);
+                        itemHoverEnter(item->shared_from_this());
+                        item->update();
+                        emit item->highlightChanged(*item, true);
+                    }
+                } 
+                _highlightedItem = item;
+
+                IPConnectivity* ipconn = dynamic_cast<IPConnectivity*>(item->parentItem());
+                auto lb = dynamic_cast<Label*>(item);
+                if (ipconn && lb) {
+                    /* Show connectivity net of interface */
+                    auto mw = dynamic_cast<IPMainWindow*>(QApplication::activeWindow());
+                    if (mw) {
+                        QList<QString> ifce_name = {lb->text()};
+                        _highlightedList = mw->getIPDesign()->highlightWires(ipconn->getInstanceName(), ifce_name);
+                        flag = true;
+                    }
+                }
+            }
+        }
+        // No item selected
+        else if (_highlightedItem) {
+            if (!event->modifiers().testFlag(Qt::ControlModifier)) {
+                if (!_selectedItems.contains(_highlightedItem)) {
+                    _highlightedItem->setHighlighted(false);
+                    _highlightedItem->update();
+                    emit _highlightedItem->highlightChanged(*_highlightedItem, false);
+                }
+                _highlightedItem = nullptr;
+            }
+            
+            if (flag) {
+                flag = false;
+
+                /* Remove wires*/
+                for (auto& it : _highlightedList.first) {
+                    removeWire(it);
+                }
+
+                /* Disable highlighted */
+                for (auto& it : _highlightedList.second) {
+                    it->setHighlighted(false);
+                }                                             
+            }
+        }
+
+        break;
+    }
+
+    case WireMode:
+    {
+        // Make sure that there's a wire
+        if (!_newWire) {
+            break;
+        }
+
+        // Transform mouse coordinates to grid positions (snapped to nearest grid point)
+        const QPointF& snappedPos = _settings.snapToGrid(event->scenePos());
+
+        // Add a new wire segment. Only allow straight angles (if supposed to)
+        if (_settings.routeStraightAngles) {
+            if (_newWireSegment) {
+                // Remove the last point if there was a previous segment
+                if (_newWire->pointsRelative().count() > 1) {
+                    _newWire->removeLastPoint();
+                }
+
+                // Create the intermediate point that creates the straight angle
+                point prevNode(_newWire->pointsAbsolute().at(_newWire->pointsAbsolute().count() - 1));
+                QPointF corner(prevNode.x(), snappedPos.y());
+                if (_invertWirePosture) {
+                    corner.setX(snappedPos.x());
+                    corner.setY(prevNode.y());
+                }
+
+                // Add the two new points
+                _newWire->append_point(corner);
+                _newWire->append_point(snappedPos);
+
+                _newWireSegment = false;
+            } else {
+                // Create the intermediate point that creates the straight angle
+                point p1(_newWire->pointsAbsolute().at(_newWire->pointsAbsolute().count() - 3));
+                QPointF p2(p1.x(), snappedPos.y());
+                QPointF p3(snappedPos);
+                if (_invertWirePosture) {
+                    p2.setX(p3.x());
+                    p2.setY(p1.y());
+                }
+
+                // Modify the actual wire
+                _newWire->move_point_to(_newWire->pointsAbsolute().count() - 2, p2);
+                _newWire->move_point_to(_newWire->pointsAbsolute().count() - 1, p3);
+            }
+        } else {
+            // Don't care about angles and stuff. Fuck geometry, right?
+            if (_newWire->pointsAbsolute().count() > 1) {
+                _newWire->move_point_to(_newWire->pointsAbsolute().count() - 1, snappedPos);
+            } else {
+                _newWire->append_point(snappedPos);
+            }
+        }
+
+        break;
+    }
+
+    }
+
+    // Save the last mouse position
+    _lastMousePos = newMousePos;
+}
+
+void Scene::mouseDoubleClickEvent(QGraphicsSceneMouseEvent* event)
+{
+    event->accept();
+
+    switch (_mode) {
+        case NormalMode:
+        {
+            //QPointF newMousePos = event->scenePos();
+            //Item* selectedItem = dynamic_cast<Item*>(itemAt(newMousePos, QTransform()));
+            //QRectF rec = selectedItem->gridRectF();
+
+            QGraphicsScene::mouseDoubleClickEvent(event);
+            return;
+        }
+
+        case WireMode:
+        {
+
+            // Only do something if there's a wire
+            if (_newWire && _newWire->pointsRelative().count() > 1) {
+
+                // Get rid of the last point as mouseDoubleClickEvent() is following mousePressEvent()
+                _newWire->removeLastPoint();
+
+                // Attach point to wire if needed
+                for (const auto& wire: m_wire_manager->wires()) {
+                    // Skip current wire
+                    if (wire == _newWire) {
+                        continue;
+                    }
+                    if (wire->point_is_on_wire(_newWire->pointsAbsolute().last())) {
+                        m_wire_manager->connect_wire(wire.get(), _newWire.get(), _newWire->pointsAbsolute().count() - 1);
+                    }
+                }
+
+                // Finish the current wire
+                finishCurrentWire();
+
+                return;
+            }
+
+            return;
+        }
+    }
+}
+
+void Scene::dragEnterEvent(QGraphicsSceneDragDropEvent* event)
+{
+    // Create a list of mime formats we can handle
+    QStringList mimeFormatsWeCanHandle {
+        MIME_TYPE_NODE,
+    };
+
+    // Check whether we can handle this drag/drop
+    for (const QString& format : mimeFormatsWeCanHandle) {
+        if (event->mimeData()->hasFormat(format)) {
+            clearSelection();
+            event->acceptProposedAction();
+            return;
+        }
+    }
+
+    event->ignore();
+}
+
+void Scene::dragMoveEvent(QGraphicsSceneDragDropEvent* event)
+{
+    event->acceptProposedAction();
+}
+
+void Scene::dragLeaveEvent(QGraphicsSceneDragDropEvent* event)
+{
+    event->acceptProposedAction();
+}
+
+void Scene::dropEvent(QGraphicsSceneDragDropEvent* event)
+{
+    event->accept();
+
+    // Check the mime data
+    const QMimeData* mimeData = event->mimeData();
+    if (!mimeData) {
+        return;
+    }
+
+    // Nodes
+    if (mimeData->hasFormat(MIME_TYPE_NODE)) {
+        // Get the ItemMimeData
+        const ItemMimeData* mimeData = qobject_cast<const ItemMimeData*>(event->mimeData());
+        if (!mimeData) {
+            return;
+        }
+
+        // Get the Item
+        auto item = mimeData->item();
+        if (!item) {
+            return;
+        }
+
+        // Add to the scene
+        item->setPos(event->scenePos());
+        _undoStack->push(new CommandItemAdd(this, std::move(item)));
+    }
+}
+
+void Scene::drawBackground(QPainter* painter, const QRectF& rect)
+{
+   painter->fillRect(rect, Qt::white);
+}
+
+QVector2D Scene::itemsMoveSnap(const std::shared_ptr<Item>& items, const QVector2D& moveBy) const
+{
+    Q_UNUSED(items);
+
+    return moveBy;
+}
+
+void Scene::renderCachedBackground()
+{
+    // Create the pixmap
+    QRect rect = sceneRect().toRect();
+    if (rect.isNull() || !rect.isValid()) {
+        return;
+    }
+    QPixmap pixmap(rect.width(), rect.height());
+
+    // Grid pen
+    QPen gridPen;
+    gridPen.setStyle(Qt::SolidLine);
+    gridPen.setColor(Qt::gray);
+    gridPen.setCapStyle(Qt::RoundCap);
+    gridPen.setWidth(_settings.gridPointSize);
+
+    // Grid brush
+    QBrush gridBrush;
+    gridBrush.setStyle(Qt::NoBrush);
+
+    // Create a painter
+    QPainter painter(&pixmap);
+    painter.setBrush(Qt::black);
+    painter.setRenderHint(QPainter::Antialiasing, _settings.antialiasing);
+
+    // Draw background
+    pixmap.fill(Qt::white);
+
+    // Draw the grid if supposed to
+    if (_settings.showGrid && (_settings.gridSize > 0)) {
+        qreal left = int(rect.left()) - (int(rect.left()) % _settings.gridSize);
+        qreal top = int(rect.top()) - (int(rect.top()) % _settings.gridSize);
+
+        // Create a list of points
+        QVector<QPointF> points;
+        for (qreal x = left; x < rect.right(); x += _settings.gridSize) {
+            for (qreal y = top; y < rect.bottom(); y += _settings.gridSize) {
+                points.append(QPointF(x,y));
+            }
+        }
+
+        // Draw the actual grid points
+        painter.setPen(gridPen);
+        painter.setBrush(gridBrush);
+        painter.drawPoints(points.data(), points.size());
+    }
+
+    // Mark the origin if supposed to
+    if (_settings.debug) {
+        painter.setPen(Qt::NoPen);
+        painter.setBrush(Qt::red);
+        painter.drawEllipse(-6, -6, 12, 12);
+    }
+
+    painter.end();
+
+    // Update
+    _backgroundPixmap = pixmap;
+    update();
+}
+
+void Scene::setupNewItem(Item& item)
+{
+    // Set settings
+    item.setSettings(_settings);
+}
+
+void Scene::generateConnections()
+{
+    for (const auto& connector : connectors()) {
+        std::shared_ptr<wire> wire = m_wire_manager->wire_with_extremity_at(connector->scenePos());
+        if (wire) {
+            m_wire_manager->attach_wire_to_connector(wire.get(), connector.get());
+        }
+    }
+}
+
+/**
+ * Finishes the current wire if there is one
+ */
+void Scene::finishCurrentWire()
+{
+    if (!_newWire) {
+        return;
+    }
+    // Finish the current wire
+    _newWire->setAcceptHoverEvents(true);
+    _newWire->setFlag(QGraphicsItem::ItemIsSelectable, true);
+    _newWire->simplify();
+//    _newWire->updatePosition();
+    _newWire.reset();
+}
+
+
+QList<QPointF> Scene::connectionPoints() const
+{
+    QList<QPointF> list;
+
+    for (const auto& node : nodes()) {
+        list << node->connectionPointsAbsolute();
+    }
+
+    return list;
+}
+
+QList<std::shared_ptr<Connector>> Scene::connectors() const
+{
+    QList<std::shared_ptr<Connector>> list;
+
+    for (const auto& node : nodes()) {
+        list << node->connectors();
+    }
+
+    return list;
+}
+
+void Scene::itemHoverEnter(const std::shared_ptr<const Item>& item)
+{
+    emit itemHighlighted(item);
+}
+
+void Scene::itemHoverLeave(const std::shared_ptr<const Item>& /*item*/)
+{
+    emit itemHighlighted(nullptr);
+}
+
+/**
+ * Removes the last point(s) of the new wire. After execution, the wire should
+ * be in the same state it was before the last point had been added.
+ */
+void Scene::removeLastWirePoint()
+{
+    if (!_newWire) {
+        return;
+    }
+
+    // If we're supposed to preseve right angles, two points have to be removed
+    if (_settings.routeStraightAngles) {
+        // Do nothing if there are not at least 4 points
+        if (_newWire->pointsAbsolute().count() > 3) {
+            // Keep the position of the last point
+            QPointF mousePos = _newWire->pointsAbsolute().last();
+            // Remove both points
+            _newWire->removeLastPoint();
+            _newWire->removeLastPoint();
+            // Move the new last point to where the previous last point was
+            _newWire->move_point_by(_newWire->pointsAbsolute().count() - 1,
+                                    QVector2D(mousePos - _newWire->pointsAbsolute().last()));
+        }
+    }
+
+    // If we don't care about the angles, only the last point has to be removed
+    else {
+        // Do nothing if there are not at least 3 points
+        if (_newWire->pointsAbsolute().count() > 2) {
+            // Keep the position of the last point
+            QPointF mousePos = _newWire->pointsAbsolute().last();
+            // Remove the point
+            _newWire->removeLastPoint();
+            // Move the new last point to where the previous last point was
+            _newWire->move_point_to(_newWire->pointsAbsolute().count() - 1, mousePos);
+        }
+    }
+}
+
+/**
+ * Removes the wires and wire nets that are not connected to a node
+ */
+void Scene::removeUnconnectedWires()
+{
+    QList<std::shared_ptr<Wire>> wiresToRemove;
+
+    for (const auto& wire : m_wire_manager->wires()) {
+        // If it has wires attached to it, go to the next wire
+        if (wire->connected_wires().count() > 0) {
+            continue;
+        }
+
+        bool isConnected = false;
+
+        // Check if it is connected to a wire
+        for (const auto& otherWire : m_wire_manager->wires()) {
+            if (otherWire->connected_wires().contains(wire.get())) {
+                isConnected = true;
+                break;
+            }
+        }
+
+        // If it's connected to a wire, go to the next wire
+        if (isConnected) {
+            continue;
+        }
+
+        // Find out if it's attached to a node
+        for (const auto& connector : connectors()) {
+            if (m_wire_manager->attached_wire(connector.get()) == wire.get()) {
+                isConnected = true;
+                break;
+            }
+        }
+
+        // If it's connected to a connector, go to the next wire
+        if (isConnected) {
+            continue;
+        }
+
+        // The wire has to be removed, add it to the list
+        if (auto wireItem = std::dynamic_pointer_cast<Wire>(wire)) {
+            wiresToRemove << wireItem;
+        }
+    }
+
+    // Remove the wires that have to be removed
+    for (const auto& wire : wiresToRemove) {
+        _undoStack->push(new CommandItemRemove(this, wire));
+    }
+}
+
+bool Scene::addWire(const std::shared_ptr<Wire>& wire)
+{
+    if (!m_wire_manager->add_wire(wire)) {
+        return false;
+    }
+
+    wire->set_manager(m_wire_manager.get());
+
+    // Add wire to scene
+    // Wires created by mouse interactions are already added to the scene in the Scene::mouseXxxEvent() calls. Prevent
+    // adding an already added item to the scene
+    if (wire->scene() != this) {
+        if (!addItem(wire)) {
+            return false;
+        }
+    }
+    return true;
+}
+
+bool Scene::removeWire(const std::shared_ptr<Wire>& wire)
+{
+    // Remove the wire from the scene
+    removeItem(wire);
+
+    // Disconnect from connectors
+    for (const auto& connector: connectors()) {
+        if (m_wire_manager->attached_wire(connector.get()) == wire.get()) {
+            m_wire_manager->detach_wire(connector.get());
+        }
+    }
+
+    return m_wire_manager->remove_wire(wire);
+}
+
+void Scene::closeLayout()
+{
+    clear();
+    emit clearPropertyPanel();
+    emit clearMainConsole();
+}
+
+void Scene::saveLayoutAs(QString filename, QWidget* parent)
+{
+    if (filename.isEmpty()) {
+        /* Do nothing in this case */
+        return;
+    }
+    fileName = filename;
+    /* Put all single QJsonObject objects to an independent one. */
+    QJsonObject content = QJsonObject();            /* Empty obj */
+    QJsonObject obj = QJsonObject();                /* Empty obj */
+    QJsonArray arr = QJsonArray();                  /* Empty arr */
+    QJsonObject pinsCoordinates = QJsonObject();    /* Empty pinsCoordinates */
+    QString proj_name = "Untitled";
+    content.insert(QString("Signature"), QString("IPStudio"));
+
+    /* Get config values*/
+    IPMainWindow* mw = dynamic_cast<IPMainWindow*>(parent);
+    if (mw) {
+        proj_name = mw->getProjectName();
+        content.insert(QString("project_name"), proj_name);
+        QString moduleFile = mw->getModuleFile();
+        QString archFile = mw->getArchFile();
+        auto cfg = QJsonObject();
+        for (const auto& it : mw->mp) {          
+            cfg.insert(QString::fromStdString(it.first), QString::fromStdString(it.second).toInt());
+        }
+        QFileInfo f(moduleFile);
+        obj.insert("moduleFile", f.fileName());
+        f.setFile(archFile);
+        obj.insert("archFile", f.fileName());
+        obj.insert("projName", mw->getProjectName());
+        obj.insert("constraint", cfg);
+    }
+    content.insert(QString("config"), obj);
+         
+    for (auto& item : _items) {       
+        IPInstance* ins = dynamic_cast<IPInstance*>(item.get());
+        if (ins) {
+            obj = QJsonObject(); /* Clear obj */
+            obj.insert("moduleName", QJsonValue(ins->getModuleName()));
+            obj.insert("instanceName", QJsonValue(ins->getinstanceName()));
+            obj.insert("posX", QJsonValue(item->posX()));
+            obj.insert("posY", QJsonValue(item->posY()));
+            obj.insert("scale", QJsonValue(item->scale()));
+            obj.insert("rotation", QJsonValue(item->rotation()));
+            obj.insert("transformOriginPointX", QJsonValue(item->transformOriginPoint().x()));
+            obj.insert("transformOriginPointY", QJsonValue(item->transformOriginPoint().y()));
+            obj.insert("isEnabled", QJsonValue(item->isEnabled()));
+            obj.insert("isSelected", QJsonValue(item->isSelected()));
+            obj.insert("zValue", QJsonValue(item->zValue()));
+            const Node* node = dynamic_cast<Node*>(item.get());
+            if (node) {
+                pinsCoordinates = QJsonObject();
+                for (const auto& conn : node->connectors()) {
+                    auto objPins = QJsonObject();
+                    QString pinName = conn->text();
+                    objPins.insert("x", QJsonValue(conn->posX()));
+                    objPins.insert("y", QJsonValue(conn->posY()));
+                    pinsCoordinates.insert(pinName, objPins);
+                }
+                obj.insert(QString("pinsCoordinates"), pinsCoordinates);
+            }                     
+            arr.push_back(obj);
+        }
+    }
+    content.insert(QString("existItems"), arr);
+
+    /* Create new file to storage all info */
+    QJsonDocument document;
+    document.setObject(content);
+    QByteArray bytes = document.toJson(QJsonDocument::Indented);
+    QFile file(fileName);
+    if (file.open(QIODevice::WriteOnly | QIODevice::Text | QIODevice::Truncate)) {
+        QTextStream iStream(&file);
+        iStream.setEncoding(QStringConverter::Utf8);
+        iStream << bytes;
+        file.close();
+    } 
+}
+
+void Scene::updateLayout(QList<itemProperty> vtItemProperty, QList<QString> lsItemDeleted)
+{
+    /* Deleted item if any */
+    for (auto const& it : lsItemDeleted) {
+        for (auto& item : _items) {
+            IPInstance* ins = dynamic_cast<IPInstance*>(item.get());
+            if (ins) {
+                if (it == ins->getModuleName()) {
+                    removeItem(item);
+                    break;
+                }
+            }
+        }
+    }
+
+    if (vtItemProperty.size() > 0) {
+        int i = 0;
+        for (auto& item : _items) {
+            item->setPos(vtItemProperty.at(i).pos);
+            item->setScale(vtItemProperty.at(i).scale);
+            item->setRotation(vtItemProperty.at(i).rotation);
+            item->setTransformOriginPoint(vtItemProperty.at(i).transformOriginPoint);
+            item->setEnabled(vtItemProperty.at(i).isEnabled);
+            item->setSelected(vtItemProperty.at(i).isSelected);
+            item->setZValue(vtItemProperty.at(i).zValue);
+
+            Node* node = dynamic_cast<Node*>(item.get());
+            if (node && (i < vtItemProperty.size())) {
+                QList<QPair<QString, QPointF>> pinList = vtItemProperty.at(i).pin;
+                for (auto& conn : node->connectors()) {                   
+                    for (auto& pin : pinList) {
+                        QString pinName = pin.first;
+                        QPointF pf(pin.second);
+                        if (pinName.indexOf(conn->text()) != -1) {
+                            /* Update position */
+                            conn->setPos(pf);
+                            pinList.removeOne(pin);
+                            break;
+                        }                        
+                    }
+                }
+                node->alignConnectorLabels();
+            }
+            i++;
+        }
+    }
+}
diff --git a/src/sw/noc_dev/IPStudio_qt6/GUI/WireSystem/wire.cpp b/src/sw/noc_dev/IPStudio_qt6/GUI/WireSystem/wire.cpp
index ce21859159e..1839338ade0 100644
--- a/src/sw/noc_dev/IPStudio_qt6/GUI/WireSystem/wire.cpp
+++ b/src/sw/noc_dev/IPStudio_qt6/GUI/WireSystem/wire.cpp
@@ -527,9 +527,9 @@ void wire::move(const QVector2D& movedBy)
     }
 
     // Move the points
-    for (int index = 0; index < points_count(); index++) {
+    /*for (int index = 0; index < points_count(); index++) {
         move_point_to(index, m_points[index].toPointF() + movedBy.toPointF());
-    }
+    }*/
 }
 
 void wire::remove_duplicate_points()
diff --git a/src/sw/noc_dev/IPStudio_qt6/include/IPConnectivity.h b/src/sw/noc_dev/IPStudio_qt6/include/IPConnectivity.h
index f49ac9fdc0b..d7d2eaa402e 100644
--- a/src/sw/noc_dev/IPStudio_qt6/include/IPConnectivity.h
+++ b/src/sw/noc_dev/IPStudio_qt6/include/IPConnectivity.h
@@ -23,7 +23,7 @@ class IPConnectivity : public QSchematic::Connector {
     Q_DISABLE_COPY(IPConnectivity)
 public:
     IPConnectivity(const QPoint& gridPoint, const QString& text, QGraphicsItem* parent);
-    IPConnectivity(const NetSpeed::BDS::IntfConn& ifce, const QPointF& gridPoint, QGraphicsItem* parent = nullptr);
+    IPConnectivity(const NetSpeed::BDS::IntfConn& ifce, const QPointF& gridPoint, QGraphicsItem* parent = nullptr, bool group = false);
     virtual ~IPConnectivity() override;
     virtual std::shared_ptr<QSchematic::Item> deepCopy() const override;
     void alignInterfaceLabel();
@@ -36,6 +36,7 @@ public:
     void paint(QPainter* painter, const QStyleOptionGraphicsItem* option, QWidget* widget);
     virtual QVariant itemChange(QGraphicsItem::GraphicsItemChange change, const QVariant& value) override;
     void copyAttributes(IPConnectivity& dest) const;
+    bool g = false;
 private:
     std::shared_ptr<QSchematic::Label> ifceLabel;
     NetSpeed::BDS::Conn_mode mode;
diff --git a/src/sw/noc_dev/IPStudio_qt6/include/IPDesign.h b/src/sw/noc_dev/IPStudio_qt6/include/IPDesign.h
index 37a7b010d26..65b0082e06f 100644
--- a/src/sw/noc_dev/IPStudio_qt6/include/IPDesign.h
+++ b/src/sw/noc_dev/IPStudio_qt6/include/IPDesign.h
@@ -46,6 +46,7 @@ public:
     const NetSpeed::BDS::Module* getModule() const { return module; }
     const std::shared_ptr<IPObject>& getIPObject() const { return object; }
     void showWires();
+    void refreshWires();
     void attachWireToNet(std::shared_ptr<QSchematic::Wire>& wire);
     void attachWireToConnector(std::shared_ptr<QSchematic::Wire>& wire, QSchematic::Node* node, const QPointF& scenePos);
     Avoid::ConnRef* computeWire(IPConnectivity* start, IPConnectivity* end, Avoid::Router* router);
@@ -75,6 +76,7 @@ private:
     ShowWiresDialog* wireDialog = nullptr;
     std::map<QString, QList<QString>> ifces;
     QMap<std::string, std::vector<IPConnectivity*>> instanceConn;
+    QList<NetSpeed::BDS::IntfConn*> outIntfConns;
     QMap<QString, std::vector<QPair<IPConnectivity*, QList<IPConnectivity*>>>> instanceWires;
     std::unordered_map<IPConnectivity*, IPConnectivity*> wiresRouted;
     const int INIT_SRAND = 9;
diff --git a/src/sw/noc_dev/IPStudio_qt6/include/IPInstance.h b/src/sw/noc_dev/IPStudio_qt6/include/IPInstance.h
index 16df693b25d..5a55f02afd1 100644
--- a/src/sw/noc_dev/IPStudio_qt6/include/IPInstance.h
+++ b/src/sw/noc_dev/IPStudio_qt6/include/IPInstance.h
@@ -29,7 +29,9 @@ public:
     void setModuleName(QString newName) { moduleName = newName; }
     void renameModule();
     void renameInstance();
+    QRectF newBoundingRect();
     std::map<NetSpeed::BDS::IntfConn, IPConnectivity*>& getPinConnectors() { return connectors; }
+    const NetSpeed::BDS::Instance* getInstance() { return instance; }
     int textLength = 0;
 private:
     const NetSpeed::BDS::Instance* instance;
