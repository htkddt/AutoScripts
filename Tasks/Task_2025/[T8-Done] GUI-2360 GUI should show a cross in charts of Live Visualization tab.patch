 src/sw/noc_dev/GUICore/Utils/qcustomplot.cpp       | 380 +++++++++++++++++++++
 src/sw/noc_dev/GUICore/Utils/qcustomplot.h         |  89 +++++
 src/sw/noc_dev/GUICore_qt6/Utils/qcustomplot.cpp   | 380 +++++++++++++++++++++
 src/sw/noc_dev/GUICore_qt6/Utils/qcustomplot.h     |  89 +++++
 src/sw/noc_dev/prototype/Gui/propertypanel.cpp     | 133 +++++++-
 src/sw/noc_dev/prototype/Utils/stattab.h           |   1 +
 src/sw/noc_dev/prototype_qt6/Gui/propertypanel.cpp | 133 +++++++-
 src/sw/noc_dev/prototype_qt6/Utils/stattab.h       |   1 +
 8 files changed, 1172 insertions(+), 34 deletions(-)

diff --git a/src/sw/noc_dev/GUICore/Utils/qcustomplot.cpp b/src/sw/noc_dev/GUICore/Utils/qcustomplot.cpp
index b36479eea03..24a29e47851 100644
--- a/src/sw/noc_dev/GUICore/Utils/qcustomplot.cpp
+++ b/src/sw/noc_dev/GUICore/Utils/qcustomplot.cpp
@@ -9241,6 +9241,72 @@ QCustomPlot::~QCustomPlot()
     mLayers.clear();
 }
 
+void QCustomPlot::initVerticalLine()
+{
+    verticalLine = new QCPItemLine(this);
+    verticalLine->start->setAxes(this->graph(0)->keyAxis(), this->graph(0)->valueAxis());
+    verticalLine->end->setAxes(this->graph(0)->keyAxis(), this->graph(0)->valueAxis());
+    verticalLine->setPen(QPen(Qt::gray, 0.5, Qt::DashLine));
+
+    labelTime = new QCPItemText(this);
+    labelTime->position->setAxes(this->graph(0)->keyAxis(), this->graph(0)->valueAxis());
+    labelTime->setColor(QColor(128, 128, 128, 150));
+
+    labelLatency = new QCPItemText(this);
+    labelLatency->position->setAxes(this->graph(1)->keyAxis(), this->graph(1)->valueAxis());
+    labelLatency->setColor(QColor(255, 0, 0, 150));
+
+    labelThroughput = new QCPItemText(this);
+    labelThroughput->position->setAxes(this->graph(2)->keyAxis(), this->graph(2)->valueAxis());
+    labelThroughput->setColor(QColor(0, 0, 255, 150));
+}
+
+void QCustomPlot::handleLegendTable(float minDataSize, float maxDataSize, float aveDataSize,
+                                    float minLatency, float maxLatency, float aveLatency,
+                                    float minThroughput, float maxThroughput, float aveThroughput) {
+    legend->insertRow(0);
+
+    auto legendMin = new QCPTextElement(this, "Min");
+    legendMin->setLayer(legend->layer());
+    legend->insertColumn(1);
+    legend->addElement(0, 1, legendMin);
+
+    auto legendMax = new QCPTextElement(this, "Max");
+    legendMax->setLayer(legend->layer());
+    legend->insertColumn(2);
+    legend->addElement(0, 2, legendMax);
+
+    auto legendAve = new QCPTextElement(this, "Average");
+    legendAve->setLayer(legend->layer());
+    legend->insertColumn(3);
+    legend->addElement(0, 3, legendAve);
+
+    for (int row = 1; row < legend->rowCount(); row++) {
+        for (int col = 1; col < legend->columnCount(); col++) {
+            auto legendText = new QCPTextElement(this);
+            legendText->setLayer(legend->layer());
+            legend->addElement(row, col, legendText);
+            switch (row) {
+            case 1:
+                if (col == 1) legendText->setText(QString::number(minDataSize));
+                else if (col == 2) legendText->setText(QString::number(maxDataSize));
+                else if (col == 3) legendText->setText(QString::number(aveDataSize));
+                break;
+            case 2:
+                if (col == 1) legendText->setText(QString::number(minLatency));
+                else if (col == 2) legendText->setText(QString::number(maxLatency));
+                else if (col == 3) legendText->setText(QString::number(aveLatency));
+                break;
+            case 3:
+                if (col == 1) legendText->setText(QString::number(minThroughput));
+                else if (col == 2) legendText->setText(QString::number(maxThroughput));
+                else if (col == 3) legendText->setText(QString::number(aveThroughput));
+                break;
+            }
+        }
+    }
+}
+
 /*!
   Sets which elements are forcibly drawn antialiased as an \a or combination of QCP::AntialiasedElement.
 
@@ -13724,6 +13790,320 @@ void QCPLegend::parentPlotInitialized(QCustomPlot * parentPlot)
     Q_UNUSED(parentPlot)
 }
 
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPTextElement
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPTextElement
+  \brief A layout element displaying a text
+
+  The text may be specified with \ref setText, the formatting can be controlled with \ref setFont,
+  \ref setTextColor, and \ref setTextFlags.
+
+  A text element can be added as follows:
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcptextelement-creation
+*/
+
+/* start documentation of signals */
+
+/*! \fn void QCPTextElement::selectionChanged(bool selected)
+
+  This signal is emitted when the selection state has changed to \a selected, either by user
+  interaction or by a direct call to \ref setSelected.
+
+  \see setSelected, setSelectable
+*/
+
+/*! \fn void QCPTextElement::clicked(QMouseEvent *event)
+
+  This signal is emitted when the text element is clicked.
+
+  \see doubleClicked, selectTest
+*/
+
+/*! \fn void QCPTextElement::doubleClicked(QMouseEvent *event)
+
+  This signal is emitted when the text element is double clicked.
+
+  \see clicked, selectTest
+*/
+
+/* end documentation of signals */
+
+/*! \overload
+
+  Creates a new QCPTextElement instance and sets default values. The initial text is empty (\ref
+  setText).
+*/
+QCPTextElement::QCPTextElement(QCustomPlot* parentPlot)
+: QCPLayoutElement(parentPlot), mText(), mTextFlags(Qt::AlignCenter | Qt::TextWordWrap),
+  mFont(QFont(QLatin1String("sans serif"), 12)),  // will be taken from parentPlot if available, see below
+  mTextColor(Qt::black),
+  mSelectedFont(QFont(QLatin1String("sans serif"), 12)),  // will be taken from parentPlot if available, see below
+  mSelectedTextColor(Qt::blue), mSelectable(false), mSelected(false) {
+    if (parentPlot) {
+        mFont         = parentPlot->font();
+        mSelectedFont = parentPlot->font();
+    }
+    setMargins(QMargins(2, 2, 2, 2));
+}
+
+/*! \overload
+
+  Creates a new QCPTextElement instance and sets default values.
+
+  The initial text is set to \a text.
+*/
+QCPTextElement::QCPTextElement(QCustomPlot* parentPlot, const QString& text)
+: QCPLayoutElement(parentPlot), mText(text), mTextFlags(Qt::AlignCenter | Qt::TextWordWrap),
+  mFont(QFont(QLatin1String("sans serif"), 12)),  // will be taken from parentPlot if available, see below
+  mTextColor(Qt::black),
+  mSelectedFont(QFont(QLatin1String("sans serif"), 12)),  // will be taken from parentPlot if available, see below
+  mSelectedTextColor(Qt::blue), mSelectable(false), mSelected(false) {
+    if (parentPlot) {
+        mFont         = parentPlot->font();
+        mSelectedFont = parentPlot->font();
+    }
+    setMargins(QMargins(2, 2, 2, 2));
+}
+
+/*! \overload
+
+  Creates a new QCPTextElement instance and sets default values.
+
+  The initial text is set to \a text with \a pointSize.
+*/
+QCPTextElement::QCPTextElement(QCustomPlot* parentPlot, const QString& text, double pointSize)
+: QCPLayoutElement(parentPlot), mText(text), mTextFlags(Qt::AlignCenter | Qt::TextWordWrap),
+  mFont(QFont(QLatin1String("sans serif"), pointSize)),  // will be taken from parentPlot if available, see below
+  mTextColor(Qt::black),
+  mSelectedFont(QFont(QLatin1String("sans serif"), pointSize)),  // will be taken from parentPlot if available, see below
+  mSelectedTextColor(Qt::blue), mSelectable(false), mSelected(false) {
+    if (parentPlot) {
+        mFont = parentPlot->font();
+        mFont.setPointSizeF(pointSize);
+        mSelectedFont = parentPlot->font();
+        mSelectedFont.setPointSizeF(pointSize);
+    }
+    setMargins(QMargins(2, 2, 2, 2));
+}
+
+/*! \overload
+
+  Creates a new QCPTextElement instance and sets default values.
+
+  The initial text is set to \a text with \a pointSize and the specified \a fontFamily.
+*/
+QCPTextElement::QCPTextElement(QCustomPlot* parentPlot, const QString& text, const QString& fontFamily, double pointSize)
+: QCPLayoutElement(parentPlot), mText(text), mTextFlags(Qt::AlignCenter | Qt::TextWordWrap),
+  mFont(QFont(fontFamily, pointSize)), mTextColor(Qt::black), mSelectedFont(QFont(fontFamily, pointSize)),
+  mSelectedTextColor(Qt::blue), mSelectable(false), mSelected(false) {
+    setMargins(QMargins(2, 2, 2, 2));
+}
+
+/*! \overload
+
+  Creates a new QCPTextElement instance and sets default values.
+
+  The initial text is set to \a text with the specified \a font.
+*/
+QCPTextElement::QCPTextElement(QCustomPlot* parentPlot, const QString& text, const QFont& font)
+: QCPLayoutElement(parentPlot), mText(text), mTextFlags(Qt::AlignCenter | Qt::TextWordWrap),
+  mFont(font), mTextColor(Qt::black), mSelectedFont(font), mSelectedTextColor(Qt::blue),
+  mSelectable(false), mSelected(false) {
+    setMargins(QMargins(2, 2, 2, 2));
+}
+
+/*!
+  Sets the text that will be displayed to \a text. Multiple lines can be created by insertion of "\n".
+
+  \see setFont, setTextColor, setTextFlags
+*/
+void QCPTextElement::setText(const QString& text) { mText = text; }
+
+/*!
+  Sets options for text alignment and wrapping behaviour. \a flags is a bitwise OR-combination of
+  \c Qt::AlignmentFlag and \c Qt::TextFlag enums.
+
+  Possible enums are:
+  - Qt::AlignLeft
+  - Qt::AlignRight
+  - Qt::AlignHCenter
+  - Qt::AlignJustify
+  - Qt::AlignTop
+  - Qt::AlignBottom
+  - Qt::AlignVCenter
+  - Qt::AlignCenter
+  - Qt::TextDontClip
+  - Qt::TextSingleLine
+  - Qt::TextExpandTabs
+  - Qt::TextShowMnemonic
+  - Qt::TextWordWrap
+  - Qt::TextIncludeTrailingSpaces
+*/
+void QCPTextElement::setTextFlags(int flags) { mTextFlags = flags; }
+
+/*!
+  Sets the \a font of the text.
+
+  \see setTextColor, setSelectedFont
+*/
+void QCPTextElement::setFont(const QFont& font) { mFont = font; }
+
+/*!
+  Sets the \a color of the text.
+
+  \see setFont, setSelectedTextColor
+*/
+void QCPTextElement::setTextColor(const QColor& color) { mTextColor = color; }
+
+/*!
+  Sets the \a font of the text that will be used if the text element is selected (\ref setSelected).
+
+  \see setFont
+*/
+void QCPTextElement::setSelectedFont(const QFont& font) { mSelectedFont = font; }
+
+/*!
+  Sets the \a color of the text that will be used if the text element is selected (\ref setSelected).
+
+  \see setTextColor
+*/
+void QCPTextElement::setSelectedTextColor(const QColor& color) { mSelectedTextColor = color; }
+
+/*!
+  Sets whether the user may select this text element.
+
+  Note that even when \a selectable is set to <tt>false</tt>, the selection state may be changed
+  programmatically via \ref setSelected.
+*/
+void QCPTextElement::setSelectable(bool selectable) {
+    if (mSelectable != selectable) {
+        mSelectable = selectable;
+        emit selectableChanged(mSelectable);
+    }
+}
+
+/*!
+  Sets the selection state of this text element to \a selected. If the selection has changed, \ref
+  selectionChanged is emitted.
+
+  Note that this function can change the selection state independently of the current \ref
+  setSelectable state.
+*/
+void QCPTextElement::setSelected(bool selected) {
+    if (mSelected != selected) {
+        mSelected = selected;
+        emit selectionChanged(mSelected);
+    }
+}
+
+/* inherits documentation from base class */
+void QCPTextElement::applyDefaultAntialiasingHint(QCPPainter* painter) const {
+    applyAntialiasingHint(painter, mAntialiased, QCP::aeOther);
+}
+
+/* inherits documentation from base class */
+void QCPTextElement::draw(QCPPainter* painter) {
+    painter->setFont(mainFont());
+    painter->setPen(QPen(mainTextColor()));
+    painter->drawText(mRect, Qt::AlignCenter, mText, &mTextBoundingRect);
+}
+
+/* inherits documentation from base class */
+QSize QCPTextElement::minimumSizeHint() const {
+    QFontMetrics metrics(mFont);
+    QSize result = metrics.boundingRect(0, 0, 0, 0, Qt::AlignCenter, mText).size();
+    result.rwidth() += mMargins.left() + mMargins.right();
+    result.rheight() += mMargins.top() + mMargins.bottom();
+    return result;
+}
+
+/* inherits documentation from base class */
+QSize QCPTextElement::maximumSizeHint() const {
+    QFontMetrics metrics(mFont);
+    QSize result = metrics.boundingRect(0, 0, 0, 0, Qt::AlignCenter, mText).size();
+    result.rheight() += mMargins.top() + mMargins.bottom();
+    result.setWidth(QWIDGETSIZE_MAX);
+    return result;
+}
+
+/* inherits documentation from base class */
+void QCPTextElement::selectEvent(QMouseEvent* event, bool additive, const QVariant& details,
+                                 bool* selectionStateChanged) {
+    Q_UNUSED(event)
+    Q_UNUSED(details)
+    if (mSelectable) {
+        bool selBefore = mSelected;
+        setSelected(additive ? !mSelected : true);
+        if (selectionStateChanged) *selectionStateChanged = mSelected != selBefore;
+    }
+}
+
+/* inherits documentation from base class */
+void QCPTextElement::deselectEvent(bool* selectionStateChanged) {
+    if (mSelectable) {
+        bool selBefore = mSelected;
+        setSelected(false);
+        if (selectionStateChanged) *selectionStateChanged = mSelected != selBefore;
+    }
+}
+
+/*!
+  Returns 0.99*selectionTolerance (see \ref QCustomPlot::setSelectionTolerance) when \a pos is
+  within the bounding box of the text element's text. Note that this bounding box is updated in the
+  draw call.
+
+  If \a pos is outside the text's bounding box or if \a onlySelectable is true and this text
+  element is not selectable (\ref setSelectable), returns -1.
+
+  \seebaseclassmethod
+*/
+double QCPTextElement::selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const {
+    Q_UNUSED(details)
+    if (onlySelectable && !mSelectable) return -1;
+
+    if (mTextBoundingRect.contains(pos.toPoint()))
+        return mParentPlot->selectionTolerance() * 0.99;
+    else
+        return -1;
+}
+
+/*!
+  Accepts the mouse event in order to emit the according click signal in the \ref
+  mouseReleaseEvent.
+
+  \seebaseclassmethod
+*/
+
+/*!
+  Emits the \ref clicked signal if the cursor hasn't moved by more than a few pixels since the \ref
+  mousePressEvent.
+
+  \seebaseclassmethod
+*/
+
+/*!
+  Emits the \ref doubleClicked signal.
+
+  \seebaseclassmethod
+*/
+
+/*! \internal
+
+  Returns the main font to be used. This is mSelectedFont if \ref setSelected is set to
+  <tt>true</tt>, else mFont is returned.
+*/
+QFont QCPTextElement::mainFont() const { return mSelected ? mSelectedFont : mFont; }
+
+/*! \internal
+
+  Returns the main color to be used. This is mSelectedTextColor if \ref setSelected is set to
+  <tt>true</tt>, else mTextColor is returned.
+*/
+QColor QCPTextElement::mainTextColor() const { return mSelected ? mSelectedTextColor : mTextColor; }
+/* end of 'src/layoutelements/layoutelement-textelement.cpp' */
+
 ////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////// QCPPlotTitle
 ////////////////////////////////////////////////////////////////////////////////////////////////////
diff --git a/src/sw/noc_dev/GUICore/Utils/qcustomplot.h b/src/sw/noc_dev/GUICore/Utils/qcustomplot.h
index 165e18a53e4..29a7f7bb8df 100644
--- a/src/sw/noc_dev/GUICore/Utils/qcustomplot.h
+++ b/src/sw/noc_dev/GUICore/Utils/qcustomplot.h
@@ -72,6 +72,9 @@ class QCPLegend;
 class QCPAbstractLegendItem;
 class QCPColorMap;
 class QCPColorScale;
+class QCPItemLine;
+class QCPItemText;
+class QCPTextElement;
 
 /*! \file */
 
@@ -125,6 +128,7 @@ namespace QCP
         , aeErrorBars = 0x0100 ///< <tt>0x0100</tt> Error bars
         , aeFills = 0x0200 ///< <tt>0x0200</tt> Borders of fills (e.g. under or between graphs)
         , aeZeroLine = 0x0400 ///< <tt>0x0400</tt> Zero-lines, see \ref QCPGrid::setZeroLinePen
+        , aeOther = 0x8000 ///< <tt>0x8000</tt> Other elements that don't fit into any of the existing categories
         , aeAll = 0xFFFF ///< <tt>0xFFFF</tt> All elements
         , aeNone = 0x0000 ///< <tt>0x0000</tt> No elements
     };
@@ -713,6 +717,82 @@ private:
     friend class QCPMarginGroup;
 };
 
+class QCP_LIB_DECL QCPTextElement : public QCPLayoutElement {
+    Q_OBJECT
+    /// \cond INCLUDE_QPROPERTIES
+    Q_PROPERTY(QString text READ text WRITE setText)
+    Q_PROPERTY(QFont font READ font WRITE setFont)
+    Q_PROPERTY(QColor textColor READ textColor WRITE setTextColor)
+    Q_PROPERTY(QFont selectedFont READ selectedFont WRITE setSelectedFont)
+    Q_PROPERTY(QColor selectedTextColor READ selectedTextColor WRITE setSelectedTextColor)
+    Q_PROPERTY(bool selectable READ selectable WRITE setSelectable NOTIFY selectableChanged)
+    Q_PROPERTY(bool selected READ selected WRITE setSelected NOTIFY selectionChanged)
+    /// \endcond
+public:
+    explicit QCPTextElement(QCustomPlot* parentPlot);
+    QCPTextElement(QCustomPlot* parentPlot, const QString& text);
+    QCPTextElement(QCustomPlot* parentPlot, const QString& text, double pointSize);
+    QCPTextElement(QCustomPlot* parentPlot, const QString& text, const QString& fontFamily, double pointSize);
+    QCPTextElement(QCustomPlot* parentPlot, const QString& text, const QFont& font);
+
+    // getters:
+    QString text() const { return mText; }
+    int textFlags() const { return mTextFlags; }
+    QFont font() const { return mFont; }
+    QColor textColor() const { return mTextColor; }
+    QFont selectedFont() const { return mSelectedFont; }
+    QColor selectedTextColor() const { return mSelectedTextColor; }
+    bool selectable() const { return mSelectable; }
+    bool selected() const { return mSelected; }
+
+    // setters:
+    void setText(const QString& text);
+    void setTextFlags(int flags);
+    void setFont(const QFont& font);
+    void setTextColor(const QColor& color);
+    void setSelectedFont(const QFont& font);
+    void setSelectedTextColor(const QColor& color);
+    Q_SLOT void setSelectable(bool selectable);
+    Q_SLOT void setSelected(bool selected);
+
+    // reimplemented virtual methods:
+    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details = 0) const Q_DECL_OVERRIDE;
+
+signals:
+    void selectionChanged(bool selected);
+    void selectableChanged(bool selectable);
+    void clicked(QMouseEvent* event);
+    void doubleClicked(QMouseEvent* event);
+
+protected:
+    // property members:
+    QString mText;
+    int mTextFlags;
+    QFont mFont;
+    QColor mTextColor;
+    QFont mSelectedFont;
+    QColor mSelectedTextColor;
+    QRect mTextBoundingRect;
+    bool mSelectable, mSelected;
+
+    // reimplemented virtual methods:
+    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const Q_DECL_OVERRIDE;
+    virtual void draw(QCPPainter* painter) Q_DECL_OVERRIDE;
+    virtual QSize minimumSizeHint() const Q_DECL_OVERRIDE;
+    virtual QSize maximumSizeHint() const Q_DECL_OVERRIDE;
+    // events:
+    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details,
+                             bool* selectionStateChanged) Q_DECL_OVERRIDE;
+    virtual void deselectEvent(bool* selectionStateChanged) Q_DECL_OVERRIDE;
+
+    // non-virtual methods:
+    QFont mainFont() const;
+    QColor mainTextColor() const;
+
+private:
+    Q_DISABLE_COPY(QCPTextElement)
+};
+
 class QCP_LIB_DECL QCPLayout : public QCPLayoutElement
 {
     Q_OBJECT
@@ -1686,6 +1766,11 @@ public:
     explicit QCustomPlot(QWidget* parent = 0);
     virtual ~QCustomPlot();
 
+    void initVerticalLine();
+    void handleLegendTable(float minDataSize, float maxDataSize, float aveDataSize,
+                           float minLatency, float maxLatency, float aveLatency,
+                           float minThroughput, float maxThroughput, float aveThroughput);
+
     // getters:
     QRect viewport() const { return mViewport; }
     QPixmap background() const { return mBackgroundPixmap; }
@@ -1791,6 +1876,10 @@ public:
 
     QCPAxis* xAxis, * yAxis, * xAxis2, * yAxis2;
     QCPLegend* legend;
+    QCPItemLine* verticalLine;
+    QCPItemText* labelTime;
+    QCPItemText* labelLatency;
+    QCPItemText* labelThroughput;
 
 signals:
     void mouseDoubleClick(QMouseEvent* event);
diff --git a/src/sw/noc_dev/GUICore_qt6/Utils/qcustomplot.cpp b/src/sw/noc_dev/GUICore_qt6/Utils/qcustomplot.cpp
index 65dbae3b205..2e114ba518c 100644
--- a/src/sw/noc_dev/GUICore_qt6/Utils/qcustomplot.cpp
+++ b/src/sw/noc_dev/GUICore_qt6/Utils/qcustomplot.cpp
@@ -9248,6 +9248,72 @@ QCustomPlot::~QCustomPlot()
     mLayers.clear();
 }
 
+void QCustomPlot::initVerticalLine()
+{
+    verticalLine = new QCPItemLine(this);
+    verticalLine->start->setAxes(this->graph(0)->keyAxis(), this->graph(0)->valueAxis());
+    verticalLine->end->setAxes(this->graph(0)->keyAxis(), this->graph(0)->valueAxis());
+    verticalLine->setPen(QPen(Qt::gray, 0.5, Qt::DashLine));
+
+    labelTime = new QCPItemText(this);
+    labelTime->position->setAxes(this->graph(0)->keyAxis(), this->graph(0)->valueAxis());
+    labelTime->setColor(QColor(128, 128, 128, 150));
+
+    labelLatency = new QCPItemText(this);
+    labelLatency->position->setAxes(this->graph(1)->keyAxis(), this->graph(1)->valueAxis());
+    labelLatency->setColor(QColor(255, 0, 0, 150));
+
+    labelThroughput = new QCPItemText(this);
+    labelThroughput->position->setAxes(this->graph(2)->keyAxis(), this->graph(2)->valueAxis());
+    labelThroughput->setColor(QColor(0, 0, 255, 150));
+}
+
+void QCustomPlot::handleLegendTable(float minDataSize, float maxDataSize, float aveDataSize,
+                                    float minLatency, float maxLatency, float aveLatency,
+                                    float minThroughput, float maxThroughput, float aveThroughput) {
+    legend->insertRow(0);
+
+    auto legendMin = new QCPTextElement(this, "Min");
+    legendMin->setLayer(legend->layer());
+    legend->insertColumn(1);
+    legend->addElement(0, 1, legendMin);
+
+    auto legendMax = new QCPTextElement(this, "Max");
+    legendMax->setLayer(legend->layer());
+    legend->insertColumn(2);
+    legend->addElement(0, 2, legendMax);
+
+    auto legendAve = new QCPTextElement(this, "Average");
+    legendAve->setLayer(legend->layer());
+    legend->insertColumn(3);
+    legend->addElement(0, 3, legendAve);
+
+    for (int row = 1; row < legend->rowCount(); row++) {
+        for (int col = 1; col < legend->columnCount(); col++) {
+            auto legendText = new QCPTextElement(this);
+            legendText->setLayer(legend->layer());
+            legend->addElement(row, col, legendText);
+            switch (row) {
+            case 1:
+                if (col == 1) legendText->setText(QString::number(minDataSize));
+                else if (col == 2) legendText->setText(QString::number(maxDataSize));
+                else if (col == 3) legendText->setText(QString::number(aveDataSize));
+                break;
+            case 2:
+                if (col == 1) legendText->setText(QString::number(minLatency));
+                else if (col == 2) legendText->setText(QString::number(maxLatency));
+                else if (col == 3) legendText->setText(QString::number(aveLatency));
+                break;
+            case 3:
+                if (col == 1) legendText->setText(QString::number(minThroughput));
+                else if (col == 2) legendText->setText(QString::number(maxThroughput));
+                else if (col == 3) legendText->setText(QString::number(aveThroughput));
+                break;
+            }
+        }
+    }
+}
+
 /*!
   Sets which elements are forcibly drawn antialiased as an \a or combination of QCP::AntialiasedElement.
 
@@ -13732,6 +13798,320 @@ void QCPLegend::parentPlotInitialized(QCustomPlot * parentPlot)
     Q_UNUSED(parentPlot)
 }
 
+////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////// QCPTextElement
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! \class QCPTextElement
+  \brief A layout element displaying a text
+
+  The text may be specified with \ref setText, the formatting can be controlled with \ref setFont,
+  \ref setTextColor, and \ref setTextFlags.
+
+  A text element can be added as follows:
+  \snippet documentation/doc-code-snippets/mainwindow.cpp qcptextelement-creation
+*/
+
+/* start documentation of signals */
+
+/*! \fn void QCPTextElement::selectionChanged(bool selected)
+
+  This signal is emitted when the selection state has changed to \a selected, either by user
+  interaction or by a direct call to \ref setSelected.
+
+  \see setSelected, setSelectable
+*/
+
+/*! \fn void QCPTextElement::clicked(QMouseEvent *event)
+
+  This signal is emitted when the text element is clicked.
+
+  \see doubleClicked, selectTest
+*/
+
+/*! \fn void QCPTextElement::doubleClicked(QMouseEvent *event)
+
+  This signal is emitted when the text element is double clicked.
+
+  \see clicked, selectTest
+*/
+
+/* end documentation of signals */
+
+/*! \overload
+
+  Creates a new QCPTextElement instance and sets default values. The initial text is empty (\ref
+  setText).
+*/
+QCPTextElement::QCPTextElement(QCustomPlot* parentPlot)
+: QCPLayoutElement(parentPlot), mText(), mTextFlags(Qt::AlignCenter | Qt::TextWordWrap),
+  mFont(QFont(QLatin1String("sans serif"), 12)),  // will be taken from parentPlot if available, see below
+  mTextColor(Qt::black),
+  mSelectedFont(QFont(QLatin1String("sans serif"), 12)),  // will be taken from parentPlot if available, see below
+  mSelectedTextColor(Qt::blue), mSelectable(false), mSelected(false) {
+    if (parentPlot) {
+        mFont         = parentPlot->font();
+        mSelectedFont = parentPlot->font();
+    }
+    setMargins(QMargins(2, 2, 2, 2));
+}
+
+/*! \overload
+
+  Creates a new QCPTextElement instance and sets default values.
+
+  The initial text is set to \a text.
+*/
+QCPTextElement::QCPTextElement(QCustomPlot* parentPlot, const QString& text)
+: QCPLayoutElement(parentPlot), mText(text), mTextFlags(Qt::AlignCenter | Qt::TextWordWrap),
+  mFont(QFont(QLatin1String("sans serif"), 12)),  // will be taken from parentPlot if available, see below
+  mTextColor(Qt::black),
+  mSelectedFont(QFont(QLatin1String("sans serif"), 12)),  // will be taken from parentPlot if available, see below
+  mSelectedTextColor(Qt::blue), mSelectable(false), mSelected(false) {
+    if (parentPlot) {
+        mFont         = parentPlot->font();
+        mSelectedFont = parentPlot->font();
+    }
+    setMargins(QMargins(2, 2, 2, 2));
+}
+
+/*! \overload
+
+  Creates a new QCPTextElement instance and sets default values.
+
+  The initial text is set to \a text with \a pointSize.
+*/
+QCPTextElement::QCPTextElement(QCustomPlot* parentPlot, const QString& text, double pointSize)
+: QCPLayoutElement(parentPlot), mText(text), mTextFlags(Qt::AlignCenter | Qt::TextWordWrap),
+  mFont(QFont(QLatin1String("sans serif"), pointSize)),  // will be taken from parentPlot if available, see below
+  mTextColor(Qt::black),
+  mSelectedFont(QFont(QLatin1String("sans serif"), pointSize)),  // will be taken from parentPlot if available, see below
+  mSelectedTextColor(Qt::blue), mSelectable(false), mSelected(false) {
+    if (parentPlot) {
+        mFont = parentPlot->font();
+        mFont.setPointSizeF(pointSize);
+        mSelectedFont = parentPlot->font();
+        mSelectedFont.setPointSizeF(pointSize);
+    }
+    setMargins(QMargins(2, 2, 2, 2));
+}
+
+/*! \overload
+
+  Creates a new QCPTextElement instance and sets default values.
+
+  The initial text is set to \a text with \a pointSize and the specified \a fontFamily.
+*/
+QCPTextElement::QCPTextElement(QCustomPlot* parentPlot, const QString& text, const QString& fontFamily, double pointSize)
+: QCPLayoutElement(parentPlot), mText(text), mTextFlags(Qt::AlignCenter | Qt::TextWordWrap),
+  mFont(QFont(fontFamily, pointSize)), mTextColor(Qt::black), mSelectedFont(QFont(fontFamily, pointSize)),
+  mSelectedTextColor(Qt::blue), mSelectable(false), mSelected(false) {
+    setMargins(QMargins(2, 2, 2, 2));
+}
+
+/*! \overload
+
+  Creates a new QCPTextElement instance and sets default values.
+
+  The initial text is set to \a text with the specified \a font.
+*/
+QCPTextElement::QCPTextElement(QCustomPlot* parentPlot, const QString& text, const QFont& font)
+: QCPLayoutElement(parentPlot), mText(text), mTextFlags(Qt::AlignCenter | Qt::TextWordWrap),
+  mFont(font), mTextColor(Qt::black), mSelectedFont(font), mSelectedTextColor(Qt::blue),
+  mSelectable(false), mSelected(false) {
+    setMargins(QMargins(2, 2, 2, 2));
+}
+
+/*!
+  Sets the text that will be displayed to \a text. Multiple lines can be created by insertion of "\n".
+
+  \see setFont, setTextColor, setTextFlags
+*/
+void QCPTextElement::setText(const QString& text) { mText = text; }
+
+/*!
+  Sets options for text alignment and wrapping behaviour. \a flags is a bitwise OR-combination of
+  \c Qt::AlignmentFlag and \c Qt::TextFlag enums.
+
+  Possible enums are:
+  - Qt::AlignLeft
+  - Qt::AlignRight
+  - Qt::AlignHCenter
+  - Qt::AlignJustify
+  - Qt::AlignTop
+  - Qt::AlignBottom
+  - Qt::AlignVCenter
+  - Qt::AlignCenter
+  - Qt::TextDontClip
+  - Qt::TextSingleLine
+  - Qt::TextExpandTabs
+  - Qt::TextShowMnemonic
+  - Qt::TextWordWrap
+  - Qt::TextIncludeTrailingSpaces
+*/
+void QCPTextElement::setTextFlags(int flags) { mTextFlags = flags; }
+
+/*!
+  Sets the \a font of the text.
+
+  \see setTextColor, setSelectedFont
+*/
+void QCPTextElement::setFont(const QFont& font) { mFont = font; }
+
+/*!
+  Sets the \a color of the text.
+
+  \see setFont, setSelectedTextColor
+*/
+void QCPTextElement::setTextColor(const QColor& color) { mTextColor = color; }
+
+/*!
+  Sets the \a font of the text that will be used if the text element is selected (\ref setSelected).
+
+  \see setFont
+*/
+void QCPTextElement::setSelectedFont(const QFont& font) { mSelectedFont = font; }
+
+/*!
+  Sets the \a color of the text that will be used if the text element is selected (\ref setSelected).
+
+  \see setTextColor
+*/
+void QCPTextElement::setSelectedTextColor(const QColor& color) { mSelectedTextColor = color; }
+
+/*!
+  Sets whether the user may select this text element.
+
+  Note that even when \a selectable is set to <tt>false</tt>, the selection state may be changed
+  programmatically via \ref setSelected.
+*/
+void QCPTextElement::setSelectable(bool selectable) {
+    if (mSelectable != selectable) {
+        mSelectable = selectable;
+        emit selectableChanged(mSelectable);
+    }
+}
+
+/*!
+  Sets the selection state of this text element to \a selected. If the selection has changed, \ref
+  selectionChanged is emitted.
+
+  Note that this function can change the selection state independently of the current \ref
+  setSelectable state.
+*/
+void QCPTextElement::setSelected(bool selected) {
+    if (mSelected != selected) {
+        mSelected = selected;
+        emit selectionChanged(mSelected);
+    }
+}
+
+/* inherits documentation from base class */
+void QCPTextElement::applyDefaultAntialiasingHint(QCPPainter* painter) const {
+    applyAntialiasingHint(painter, mAntialiased, QCP::aeOther);
+}
+
+/* inherits documentation from base class */
+void QCPTextElement::draw(QCPPainter* painter) {
+    painter->setFont(mainFont());
+    painter->setPen(QPen(mainTextColor()));
+    painter->drawText(mRect, Qt::AlignCenter, mText, &mTextBoundingRect);
+}
+
+/* inherits documentation from base class */
+QSize QCPTextElement::minimumSizeHint() const {
+    QFontMetrics metrics(mFont);
+    QSize result = metrics.boundingRect(0, 0, 0, 0, Qt::AlignCenter, mText).size();
+    result.rwidth() += mMargins.left() + mMargins.right();
+    result.rheight() += mMargins.top() + mMargins.bottom();
+    return result;
+}
+
+/* inherits documentation from base class */
+QSize QCPTextElement::maximumSizeHint() const {
+    QFontMetrics metrics(mFont);
+    QSize result = metrics.boundingRect(0, 0, 0, 0, Qt::AlignCenter, mText).size();
+    result.rheight() += mMargins.top() + mMargins.bottom();
+    result.setWidth(QWIDGETSIZE_MAX);
+    return result;
+}
+
+/* inherits documentation from base class */
+void QCPTextElement::selectEvent(QMouseEvent* event, bool additive, const QVariant& details,
+                                 bool* selectionStateChanged) {
+    Q_UNUSED(event)
+    Q_UNUSED(details)
+    if (mSelectable) {
+        bool selBefore = mSelected;
+        setSelected(additive ? !mSelected : true);
+        if (selectionStateChanged) *selectionStateChanged = mSelected != selBefore;
+    }
+}
+
+/* inherits documentation from base class */
+void QCPTextElement::deselectEvent(bool* selectionStateChanged) {
+    if (mSelectable) {
+        bool selBefore = mSelected;
+        setSelected(false);
+        if (selectionStateChanged) *selectionStateChanged = mSelected != selBefore;
+    }
+}
+
+/*!
+  Returns 0.99*selectionTolerance (see \ref QCustomPlot::setSelectionTolerance) when \a pos is
+  within the bounding box of the text element's text. Note that this bounding box is updated in the
+  draw call.
+
+  If \a pos is outside the text's bounding box or if \a onlySelectable is true and this text
+  element is not selectable (\ref setSelectable), returns -1.
+
+  \seebaseclassmethod
+*/
+double QCPTextElement::selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const {
+    Q_UNUSED(details)
+    if (onlySelectable && !mSelectable) return -1;
+
+    if (mTextBoundingRect.contains(pos.toPoint()))
+        return mParentPlot->selectionTolerance() * 0.99;
+    else
+        return -1;
+}
+
+/*!
+  Accepts the mouse event in order to emit the according click signal in the \ref
+  mouseReleaseEvent.
+
+  \seebaseclassmethod
+*/
+
+/*!
+  Emits the \ref clicked signal if the cursor hasn't moved by more than a few pixels since the \ref
+  mousePressEvent.
+
+  \seebaseclassmethod
+*/
+
+/*!
+  Emits the \ref doubleClicked signal.
+
+  \seebaseclassmethod
+*/
+
+/*! \internal
+
+  Returns the main font to be used. This is mSelectedFont if \ref setSelected is set to
+  <tt>true</tt>, else mFont is returned.
+*/
+QFont QCPTextElement::mainFont() const { return mSelected ? mSelectedFont : mFont; }
+
+/*! \internal
+
+  Returns the main color to be used. This is mSelectedTextColor if \ref setSelected is set to
+  <tt>true</tt>, else mTextColor is returned.
+*/
+QColor QCPTextElement::mainTextColor() const { return mSelected ? mSelectedTextColor : mTextColor; }
+/* end of 'src/layoutelements/layoutelement-textelement.cpp' */
+
 ////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////// QCPPlotTitle
 ////////////////////////////////////////////////////////////////////////////////////////////////////
diff --git a/src/sw/noc_dev/GUICore_qt6/Utils/qcustomplot.h b/src/sw/noc_dev/GUICore_qt6/Utils/qcustomplot.h
index fe07087b01f..08a931cf25b 100644
--- a/src/sw/noc_dev/GUICore_qt6/Utils/qcustomplot.h
+++ b/src/sw/noc_dev/GUICore_qt6/Utils/qcustomplot.h
@@ -73,6 +73,9 @@ class QCPLegend;
 class QCPAbstractLegendItem;
 class QCPColorMap;
 class QCPColorScale;
+class QCPItemLine;
+class QCPItemText;
+class QCPTextElement;
 
 /*! \file */
 
@@ -126,6 +129,7 @@ namespace QCP
         , aeErrorBars = 0x0100 ///< <tt>0x0100</tt> Error bars
         , aeFills = 0x0200 ///< <tt>0x0200</tt> Borders of fills (e.g. under or between graphs)
         , aeZeroLine = 0x0400 ///< <tt>0x0400</tt> Zero-lines, see \ref QCPGrid::setZeroLinePen
+        , aeOther = 0x8000 ///< <tt>0x8000</tt> Other elements that don't fit into any of the existing categories
         , aeAll = 0xFFFF ///< <tt>0xFFFF</tt> All elements
         , aeNone = 0x0000 ///< <tt>0x0000</tt> No elements
     };
@@ -714,6 +718,82 @@ private:
     friend class QCPMarginGroup;
 };
 
+class QCP_LIB_DECL QCPTextElement : public QCPLayoutElement {
+    Q_OBJECT
+    /// \cond INCLUDE_QPROPERTIES
+    Q_PROPERTY(QString text READ text WRITE setText)
+    Q_PROPERTY(QFont font READ font WRITE setFont)
+    Q_PROPERTY(QColor textColor READ textColor WRITE setTextColor)
+    Q_PROPERTY(QFont selectedFont READ selectedFont WRITE setSelectedFont)
+    Q_PROPERTY(QColor selectedTextColor READ selectedTextColor WRITE setSelectedTextColor)
+    Q_PROPERTY(bool selectable READ selectable WRITE setSelectable NOTIFY selectableChanged)
+    Q_PROPERTY(bool selected READ selected WRITE setSelected NOTIFY selectionChanged)
+    /// \endcond
+public:
+    explicit QCPTextElement(QCustomPlot* parentPlot);
+    QCPTextElement(QCustomPlot* parentPlot, const QString& text);
+    QCPTextElement(QCustomPlot* parentPlot, const QString& text, double pointSize);
+    QCPTextElement(QCustomPlot* parentPlot, const QString& text, const QString& fontFamily, double pointSize);
+    QCPTextElement(QCustomPlot* parentPlot, const QString& text, const QFont& font);
+
+    // getters:
+    QString text() const { return mText; }
+    int textFlags() const { return mTextFlags; }
+    QFont font() const { return mFont; }
+    QColor textColor() const { return mTextColor; }
+    QFont selectedFont() const { return mSelectedFont; }
+    QColor selectedTextColor() const { return mSelectedTextColor; }
+    bool selectable() const { return mSelectable; }
+    bool selected() const { return mSelected; }
+
+    // setters:
+    void setText(const QString& text);
+    void setTextFlags(int flags);
+    void setFont(const QFont& font);
+    void setTextColor(const QColor& color);
+    void setSelectedFont(const QFont& font);
+    void setSelectedTextColor(const QColor& color);
+    Q_SLOT void setSelectable(bool selectable);
+    Q_SLOT void setSelected(bool selected);
+
+    // reimplemented virtual methods:
+    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details = 0) const Q_DECL_OVERRIDE;
+
+signals:
+    void selectionChanged(bool selected);
+    void selectableChanged(bool selectable);
+    void clicked(QMouseEvent* event);
+    void doubleClicked(QMouseEvent* event);
+
+protected:
+    // property members:
+    QString mText;
+    int mTextFlags;
+    QFont mFont;
+    QColor mTextColor;
+    QFont mSelectedFont;
+    QColor mSelectedTextColor;
+    QRect mTextBoundingRect;
+    bool mSelectable, mSelected;
+
+    // reimplemented virtual methods:
+    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const Q_DECL_OVERRIDE;
+    virtual void draw(QCPPainter* painter) Q_DECL_OVERRIDE;
+    virtual QSize minimumSizeHint() const Q_DECL_OVERRIDE;
+    virtual QSize maximumSizeHint() const Q_DECL_OVERRIDE;
+    // events:
+    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details,
+                             bool* selectionStateChanged) Q_DECL_OVERRIDE;
+    virtual void deselectEvent(bool* selectionStateChanged) Q_DECL_OVERRIDE;
+
+    // non-virtual methods:
+    QFont mainFont() const;
+    QColor mainTextColor() const;
+
+private:
+    Q_DISABLE_COPY(QCPTextElement)
+};
+
 class QCP_LIB_DECL QCPLayout : public QCPLayoutElement
 {
     Q_OBJECT
@@ -1687,6 +1767,11 @@ public:
     explicit QCustomPlot(QWidget* parent = 0);
     virtual ~QCustomPlot();
 
+    void initVerticalLine();
+    void handleLegendTable(float minDataSize, float maxDataSize, float aveDataSize,
+                           float minLatency, float maxLatency, float aveLatency,
+                           float minThroughput, float maxThroughput, float aveThroughput);
+
     // getters:
     QRect viewport() const { return mViewport; }
     QPixmap background() const { return mBackgroundPixmap; }
@@ -1792,6 +1877,10 @@ public:
 
     QCPAxis* xAxis, * yAxis, * xAxis2, * yAxis2;
     QCPLegend* legend;
+    QCPItemLine* verticalLine;
+    QCPItemText* labelTime;
+    QCPItemText* labelLatency;
+    QCPItemText* labelThroughput;
 
 signals:
     void mouseDoubleClick(QMouseEvent* event);
diff --git a/src/sw/noc_dev/prototype/Gui/propertypanel.cpp b/src/sw/noc_dev/prototype/Gui/propertypanel.cpp
index cce09555794..188c8594d41 100644
--- a/src/sw/noc_dev/prototype/Gui/propertypanel.cpp
+++ b/src/sw/noc_dev/prototype/Gui/propertypanel.cpp
@@ -3035,6 +3035,10 @@ QWidget* PropertyPanel::createStatTabLayout(QSharedPointer<StatTab> statTab, QMa
         customPlotMap.insert(name, g);
         // Create widget which include buttons and plot
         auto plotSplitter = createButtonPlotWidget(customPlot, gl, name);
+        customPlot->initVerticalLine();
+        customPlot->handleLegendTable(g.sumTable_minDataSize, g.sumTable_maxDataSize, g.sumTable_avgDataSize,
+            g.sumTable_minLatency, g.sumTable_maxLatency, g.sumTable_avgLatency,
+            g.sumTable_minThroughput, g.sumTable_maxThroughput, g.sumTable_avgThroughput);
         // Add to main layout
         graphsSplitter->addWidget(plotSplitter);
         updateNormalPlot(statTab, g, customPlot, reopenLiveTab);
@@ -3061,7 +3065,7 @@ QWidget* PropertyPanel::createStatTabLayout(QSharedPointer<StatTab> statTab, QMa
         initComparisonPlot(name, customPlot, it.second);
         // Create widget which include buttons and plot
         auto plotSplitter = createComparisonPlotWidget(customPlot, cl);
-
+        customPlot->initVerticalLine();
         // Add to main layout
         graphsSplitter->addWidget(plotSplitter);
         updateComparisonPlot(statTab, p, name, customPlot);
@@ -3186,6 +3190,18 @@ void PropertyPanel::getStatTabData(QSharedPointer<StatTab> liveStat)
 
 void PropertyPanel::showComparePointToolTip(QMouseEvent * event)
 {
+    auto updateVerticalLine = [](QCustomPlot* customPlot, double time, double value, double maxValueAxis) -> void {
+        if (customPlot->verticalLine && customPlot->labelTime && time > 0 && value > 0) {
+
+            customPlot->verticalLine->start->setCoords(time, 0);
+            customPlot->verticalLine->end->setCoords(time, maxValueAxis);
+            // Handle time label at mouse position
+            customPlot->labelTime->setText("Time (ns): " + QString::number(time));
+            customPlot->labelTime->setPositionAlignment(Qt::AlignRight | Qt::AlignBottom);
+            customPlot->labelTime->setRotation(-90);
+            customPlot->labelTime->position->setCoords(time, value);
+        }
+    };
     // Right-drag and zoom
     if (rubberBand)
     {
@@ -3196,7 +3212,12 @@ void PropertyPanel::showComparePointToolTip(QMouseEvent * event)
     if (QObject::sender()) {
         QCustomPlot* customPlot = dynamic_cast<QCustomPlot*>(QObject::sender());
         if (!customPlot) return;
-
+        double time = customPlot->graph(0)->keyAxis()->pixelToCoord(event->localPos().x());
+        double value = customPlot->graph(0)->valueAxis()->pixelToCoord(event->localPos().y());
+        double stepValueAxis = customPlot->graph(0)->valueAxis()->tickStep();
+        if ((value > 0) && (value < stepValueAxis * 2)) value = stepValueAxis * 2;
+        else if ((value > 0) && (value > stepValueAxis * 5)) value = stepValueAxis * 5;
+        double maxValueAxis = customPlot->graph(0)->valueAxis()->range().maxRange;
         // Find related evengroup
         QSharedPointer<StatTab> statTab = mw->getTabStatTabMap().value(mw->getDisplayPanel()->currentWidget(), nullptr);
         if (!statTab) return;
@@ -3240,6 +3261,8 @@ void PropertyPanel::showComparePointToolTip(QMouseEvent * event)
             } else if (hasMessage) {
                 customPlot->setToolTip(msg);
             }
+            updateVerticalLine(customPlot, time, value, maxValueAxis);
+            customPlot->replot();
         } else {
             customPlot->setToolTip("Click or 'Ctrl + Click' to highlight charts.");
         }
@@ -3409,9 +3432,30 @@ void PropertyPanel::handleMouseRelease(QMouseEvent * event)
 
 void PropertyPanel::showPointToolTip(QMouseEvent * event)
 {
+    auto updateVerticalLine = [](QCustomPlot* customPlot, double time, double value, double maxValueAxis,
+                                  double latencyValue, double throughputValue) -> void {
+        if (customPlot->verticalLine && customPlot->labelTime && customPlot->labelLatency &&
+            customPlot->labelThroughput && time > 0 && value > 0) {
+
+            customPlot->verticalLine->start->setCoords(time, 0);
+            customPlot->verticalLine->end->setCoords(time, maxValueAxis);
+            // Handle time label at mouse position
+            customPlot->labelTime->setText("Time (ns): " + QString::number(time));
+            customPlot->labelTime->setPositionAlignment(Qt::AlignRight | Qt::AlignBottom);
+            customPlot->labelTime->setRotation(-90);
+            customPlot->labelTime->position->setCoords(time, value);
+            // Handle latency label at mouse position
+            customPlot->labelLatency->setText(QString::number(latencyValue));
+            customPlot->labelLatency->setPositionAlignment(Qt::AlignLeft | Qt::AlignTop);
+            customPlot->labelLatency->position->setCoords(time, latencyValue);
+            // Handle throughput label at mouse position
+            customPlot->labelThroughput->setText(QString::number(throughputValue));
+            customPlot->labelThroughput->setPositionAlignment(Qt::AlignRight | Qt::AlignTop);
+            customPlot->labelThroughput->position->setCoords(time, throughputValue);
+        }
+    };
     // Right-drag and zoom
-    if (rubberBand)
-    {
+    if (rubberBand) {
         rubberBand->setGeometry(QRect(origin, event->pos()).normalized());
         return;
     }
@@ -3422,6 +3466,14 @@ void PropertyPanel::showPointToolTip(QMouseEvent * event)
     {
         QCustomPlot* customPlot = dynamic_cast<QCustomPlot*>(QObject::sender());
         if (!customPlot) return;
+        double time = customPlot->graph(0)->keyAxis()->pixelToCoord(event->localPos().x());
+        double value = customPlot->graph(0)->valueAxis()->pixelToCoord(event->localPos().y());
+        double stepValueAxis = customPlot->graph(0)->valueAxis()->tickStep();
+        if ((value > 0) && (value < stepValueAxis * 2)) value = stepValueAxis * 2;
+        else if ((value > 0) && (value > stepValueAxis * 5)) value = stepValueAxis * 5;
+        double maxValueAxis = customPlot->graph(0)->valueAxis()->range().maxRange;
+        double latencyValue = 0;
+        double throughputValue = 0;
 
         // Find related evengroup
         QSharedPointer<StatTab> statTab = mw->getTabStatTabMap().value(mw->getDisplayPanel()->currentWidget(), nullptr);
@@ -3435,8 +3487,7 @@ void PropertyPanel::showPointToolTip(QMouseEvent * event)
         int graphix = -1, outsidecnt = 0;
         if (!customPlot->axisRect(0) || !customPlot->axisRect(0)->axis(QCPAxis::atBottom, 0)) return;
         auto coord = customPlot->axisRect(0)->axis(QCPAxis::atBottom, 0)->pixelToCoord(event->localPos().x());
-        for (auto i = 0; i < customPlot->axisRect(0)->axes().size(); i++)
-        {
+        for (auto i = 0; i < customPlot->axisRect(0)->axes().size(); i++) {
             double coordy = customPlot->axisRect(0)->axes()[i]->pixelToCoord(event->localPos().y());
             graphix = -1;
             QString lbl = customPlot->axisRect(0)->axes()[i]->label();
@@ -3450,17 +3501,22 @@ void PropertyPanel::showPointToolTip(QMouseEvent * event)
                 graphix = 2;
             else if (lbl.contains("Data"))
                 graphix = 0;
-            if (graphix != -1)
-            {
+            if (graphix != -1) {
                 if (customPlot->graphCount() <= graphix || !customPlot->graph(graphix)->data()) return;
                 QCPData dat = customPlot->graph(graphix)->data()->lowerBound(coord).value();
                 float cc = dat.value - coordy;
+                if (graphix == 1) {
+                    if (!eg.showLatency) continue;
+                    latencyValue = dat.value;
+                }
+                if (graphix == 2) {
+                    if (!eg.showThroughput) continue;
+                    throughputValue = dat.value;
+                }
+                if (graphix == 0 && !eg.showDataSize) continue;
+                if (graphix == 3 && !eg.showIdleLatency) continue;
                 if (cc >= 0 && cc <= dat.value / 4) //Inside the graph
                 {
-                    if (graphix == 1 && !eg.showLatency) continue;
-                    if (graphix == 2 && !eg.showThroughput) continue;
-                    if (graphix == 0 && !eg.showDataSize) continue;
-                    if (graphix == 3 && !eg.showIdleLatency) continue;
                     hasMessage = true;
                     msg = msg + lbl + ":";
                     msg = msg + QString::number(dat.value) + "\n";
@@ -3475,6 +3531,7 @@ void PropertyPanel::showPointToolTip(QMouseEvent * event)
         if (hasMessage) //Display the exact value
         {
             customPlot->setToolTip(msg);
+            updateVerticalLine(customPlot, time, value, maxValueAxis, latencyValue, throughputValue);
         }
         else if (outside && outsidecnt >= 3) //Display the graph title
         {
@@ -3482,10 +3539,14 @@ void PropertyPanel::showPointToolTip(QMouseEvent * event)
         }
         else //Display stat table (avg,max,min)
         {
-            eg.get_graphs_points(statTab);
-            QString html = createTableStat(eg);
-            customPlot->setToolTip(html);
+            updateVerticalLine(customPlot, time, value, maxValueAxis, latencyValue, throughputValue);
+            if (!eg.showLegend) {
+                eg.get_graphs_points(statTab);
+                QString html = createTableStat(eg);
+                customPlot->setToolTip(html);
+            }
         }
+        customPlot->replot();
     }
 }
 
@@ -3519,6 +3580,7 @@ void PropertyPanel::updatePlotsStatTab(QWidget * splitter, QSharedPointer<StatTa
         auto customPlot = namePlotMap->value(name);
         setPlotVisible(customPlot, g.enabled);
         if (!g.enabled) continue;
+        bool init = false;
         // Init plot
         if (!customPlot) {
             customPlot = new QCustomPlot();
@@ -3534,6 +3596,8 @@ void PropertyPanel::updatePlotsStatTab(QWidget * splitter, QSharedPointer<StatTa
             // Create widget which include buttons and plot
             auto* plotSplitter = createButtonPlotWidget(customPlot, gl, name, statTab);
             splitter->layout()->addWidget(plotSplitter);
+
+            init = true;
         }
 
         if (customPlotMap.find(name) == customPlotMap.end()) {
@@ -3541,6 +3605,13 @@ void PropertyPanel::updatePlotsStatTab(QWidget * splitter, QSharedPointer<StatTa
             customPlotMap.insert(name, g);
         }
 
+        if (init) {
+            customPlot->initVerticalLine();
+            customPlot->handleLegendTable(g.sumTable_minDataSize, g.sumTable_maxDataSize, g.sumTable_avgDataSize,
+                g.sumTable_minLatency, g.sumTable_maxLatency, g.sumTable_avgLatency,
+                g.sumTable_minThroughput, g.sumTable_maxThroughput, g.sumTable_avgThroughput);
+        }
+
         // Reset map title
         QString graphName = QString::fromStdString(gl);
         int graphNameLimit = 50;
@@ -3589,6 +3660,7 @@ void PropertyPanel::updatePlotsStatTab(QWidget * splitter, QSharedPointer<StatTa
             // Add to bottom of main layout
             splitter->layout()->addWidget(plotSplitter);
             customPlot->setToolTip(wrapTextForTooltip(QString::fromStdString(p.name), plotTooltipWrap));
+            customPlot->initVerticalLine();
         }
         updateComparisonPlot(statTab, p, name, customPlot);
     }
@@ -3788,6 +3860,9 @@ GraphSplitter* PropertyPanel::createButtonPlotWidget(QCustomPlot * customPlot, c
     INICheckBox* showLegend = new INICheckBox("Legend", QString::fromStdString(gl), fullName);
     showLegend->setCheckState(Qt::Checked);
 
+    INICheckBox* showVerticalLine = new INICheckBox("Vertical Line", QString::fromStdString(gl), fullName);
+    showVerticalLine->setCheckState(Qt::Checked);
+
     zoomInGraph->setAutoDefault(false);
     zoomInGraph->setDefault(false);
     zoomOutGraph->setAutoDefault(false);
@@ -3827,6 +3902,7 @@ GraphSplitter* PropertyPanel::createButtonPlotWidget(QCustomPlot * customPlot, c
     zoomButtonlayout->addWidget(showThroughput);
     zoomButtonlayout->addWidget(showIdleLatency);
     zoomButtonlayout->addWidget(showLegend);
+    zoomButtonlayout->addWidget(showVerticalLine);
     zoomButtonlayout->addWidget(binInterval);
     zoomButtonlayout->addWidget(binIntervalLabel);
     zoomButtonlayout->addWidget(binSize);
@@ -3845,6 +3921,7 @@ GraphSplitter* PropertyPanel::createButtonPlotWidget(QCustomPlot * customPlot, c
     connect(showThroughput, SIGNAL(clicked(bool)), this, SLOT(showGraphInNomarPlot(bool)));
     connect(showIdleLatency, SIGNAL(clicked(bool)), this, SLOT(showGraphInNomarPlot(bool)));
     connect(showLegend, SIGNAL(clicked(bool)), this, SLOT(showGraphInNomarPlot(bool)));
+    connect(showVerticalLine, SIGNAL(clicked(bool)), this, SLOT(showGraphInNomarPlot(bool)));
 
     connect(startTime, SIGNAL(editingFinished()), this, SLOT(binSizeChangedInNormarPlot()));
     connect(binSize, SIGNAL(editingFinished()), this, SLOT(binSizeChangedInNormarPlot()));
@@ -3905,6 +3982,9 @@ GraphSplitter* PropertyPanel::createComparisonPlotWidget(QCustomPlot * customPlo
     if (plot->throughput) showThroughput->setCheckState(Qt::Checked);
     else showThroughput->setCheckState(Qt::Unchecked);
 
+    INICheckBox* showVerticalLine = new INICheckBox("Vertical Line", QString::fromStdString(gl), fullName);
+    showVerticalLine->setCheckState(Qt::Checked);
+
     QString tooltip = "Start time is the time at which the performance stats currently displayed in the plot begins. If start time is 109 and zoom level is for 1000ns, then performance stats between 109ns and 1109ns would be displayed.";
     INILineEdit* startTime = new INILineEdit(QString::number((long)plot->zoomLower), QString::fromStdString(gl), fullName, INILineEdit::StartTime);
     startTime->setMaximumWidth(textInputLength);
@@ -3931,6 +4011,7 @@ GraphSplitter* PropertyPanel::createComparisonPlotWidget(QCustomPlot * customPlo
     zoomButtonlayout->addWidget(showLatency);
     zoomButtonlayout->addWidget(showPkt);
     zoomButtonlayout->addWidget(showThroughput);
+    zoomButtonlayout->addWidget(showVerticalLine);
     zoomButtonlayout->addWidget(binInterval);
     zoomButtonlayout->addWidget(binIntervalLabel);
     zoomButtonlayout->addWidget(binSize);
@@ -3947,6 +4028,7 @@ GraphSplitter* PropertyPanel::createComparisonPlotWidget(QCustomPlot * customPlo
     connect(showLatency, SIGNAL(clicked(bool)), this, SLOT(showGraphInComparePlot(bool)));
     connect(showPkt, SIGNAL(clicked(bool)), this, SLOT(showGraphInComparePlot(bool)));
     connect(showThroughput, SIGNAL(clicked(bool)), this, SLOT(showGraphInComparePlot(bool)));
+    connect(showVerticalLine, SIGNAL(clicked(bool)), this, SLOT(showGraphInComparePlot(bool)));
 
     connect(startTime, SIGNAL(editingFinished()), this, SLOT(binSizeChangedInComparePlot()));
     connect(binSize, SIGNAL(editingFinished()), this, SLOT(binSizeChangedInComparePlot()));
@@ -4527,16 +4609,29 @@ void PropertyPanel::showGraphInNomarPlot(bool show)
     std::map<group_label, EventGroup>* evenGroups = &statTab->groups;
     EventGroup& eg = evenGroups->at(checkBox->getEventGroupName().toStdString());
     if (checkBox->text() == "Apply To All") eg.applyToAll = show;
-    if (checkBox->text() == "Latency") eg.showLatency = show;
     if (checkBox->text() == "Data Size") eg.showDataSize = show;
-    if (checkBox->text() == "Throughput") eg.showThroughput = show;
     if (checkBox->text() == "Idle Latency") eg.showIdleLatency = show;
     // Get and update plot in current widget
     QCustomPlot * cPlot = plotMap->value(checkBox->getEventGroupName(), nullptr);
     if (!cPlot) return;
     if (checkBox->text() == "Legend") {
+        eg.showLegend = show;
         cPlot->legend->setVisible(show);
     }
+    if (checkBox->text() == "Latency") {
+        eg.showLatency = show;
+        cPlot->labelLatency->setVisible(show);
+    }
+    if (checkBox->text() == "Throughput") {
+        eg.showThroughput = show;
+        cPlot->labelThroughput->setVisible(show);
+    }
+    if (checkBox->text() == "Vertical Line") {
+        cPlot->verticalLine->setVisible(show);
+        cPlot->labelTime->setVisible(show);
+        cPlot->labelLatency->setVisible(show);
+        cPlot->labelThroughput->setVisible(show);
+    }
     updateNormalPlot(statTab, eg, cPlot, true);
     cPlot->replot();
 }
@@ -5176,6 +5271,10 @@ void PropertyPanel::showGraphInComparePlot(bool show)
     // Get and update plot in focusing widget
     QCustomPlot * cplot = plotMap->value(checkBox->getEventGroupName(), nullptr);
     if (!cplot) return;
+    if (checkBox->text() == "Vertical Line") {
+        cplot->verticalLine->setVisible(show);
+        cplot->labelTime->setVisible(show);
+    }
     updateComparisonPlot(statTab, plot, checkBox->getEventGroupName(), cplot);
 }
 
diff --git a/src/sw/noc_dev/prototype/Utils/stattab.h b/src/sw/noc_dev/prototype/Utils/stattab.h
index 4d340e34a7e..fc441e65cae 100644
--- a/src/sw/noc_dev/prototype/Utils/stattab.h
+++ b/src/sw/noc_dev/prototype/Utils/stattab.h
@@ -48,6 +48,7 @@ struct EventGroup {
     bool showDataSize = true;
     bool showThroughput = true;
     bool showIdleLatency = true;
+    bool showLegend = true;
     double zoomLower = 0;
     double zoomUpper = 10000;
     bool showLatencyHistogram = false;
diff --git a/src/sw/noc_dev/prototype_qt6/Gui/propertypanel.cpp b/src/sw/noc_dev/prototype_qt6/Gui/propertypanel.cpp
index 3421df3d5b3..f7668464928 100644
--- a/src/sw/noc_dev/prototype_qt6/Gui/propertypanel.cpp
+++ b/src/sw/noc_dev/prototype_qt6/Gui/propertypanel.cpp
@@ -3038,6 +3038,10 @@ QWidget* PropertyPanel::createStatTabLayout(QSharedPointer<StatTab> statTab, QMa
         customPlotMap.insert(name, g);
         // Create widget which include buttons and plot
         auto plotSplitter = createButtonPlotWidget(customPlot, gl, name);
+        customPlot->initVerticalLine();
+        customPlot->handleLegendTable(g.sumTable_minDataSize, g.sumTable_maxDataSize, g.sumTable_avgDataSize,
+            g.sumTable_minLatency, g.sumTable_maxLatency, g.sumTable_avgLatency,
+            g.sumTable_minThroughput, g.sumTable_maxThroughput, g.sumTable_avgThroughput);
         // Add to main layout
         graphsSplitter->addWidget(plotSplitter);
         updateNormalPlot(statTab, g, customPlot, reopenLiveTab);
@@ -3062,7 +3066,7 @@ QWidget* PropertyPanel::createStatTabLayout(QSharedPointer<StatTab> statTab, QMa
         initComparisonPlot(name, customPlot, it.second);
         // Create widget which include buttons and plot
         auto plotSplitter = createComparisonPlotWidget(customPlot, cl);
-
+        customPlot->initVerticalLine();
         // Add to main layout
         graphsSplitter->addWidget(plotSplitter);
         updateComparisonPlot(statTab, p, name, customPlot);
@@ -3187,6 +3191,18 @@ void PropertyPanel::getStatTabData(QSharedPointer<StatTab> liveStat)
 
 void PropertyPanel::showComparePointToolTip(QMouseEvent * event)
 {
+    auto updateVerticalLine = [](QCustomPlot* customPlot, double time, double value, double maxValueAxis) -> void {
+        if (customPlot->verticalLine && customPlot->labelTime && time > 0 && value > 0) {
+
+            customPlot->verticalLine->start->setCoords(time, 0);
+            customPlot->verticalLine->end->setCoords(time, maxValueAxis);
+            // Handle time label at mouse position
+            customPlot->labelTime->setText("Time (ns): " + QString::number(time));
+            customPlot->labelTime->setPositionAlignment(Qt::AlignRight | Qt::AlignBottom);
+            customPlot->labelTime->setRotation(-90);
+            customPlot->labelTime->position->setCoords(time, value);
+        }
+    };
     // Right-drag and zoom
     if (rubberBand)
     {
@@ -3197,7 +3213,12 @@ void PropertyPanel::showComparePointToolTip(QMouseEvent * event)
     if (QObject::sender()) {
         QCustomPlot* customPlot = dynamic_cast<QCustomPlot*>(QObject::sender());
         if (!customPlot) return;
-
+        double time = customPlot->graph(0)->keyAxis()->pixelToCoord(event->localPos().x());
+        double value = customPlot->graph(0)->valueAxis()->pixelToCoord(event->localPos().y());
+        double stepValueAxis = customPlot->graph(0)->valueAxis()->tickStep();
+        if ((value > 0) && (value < stepValueAxis * 2)) value = stepValueAxis * 2;
+        else if ((value > 0) && (value > stepValueAxis * 5)) value = stepValueAxis * 5;
+        double maxValueAxis = customPlot->graph(0)->valueAxis()->range().maxRange;
         // Find related evengroup
         QSharedPointer<StatTab> statTab = mw->getTabStatTabMap().value(mw->getDisplayPanel()->currentWidget(), nullptr);
         if (!statTab) return;
@@ -3241,6 +3262,8 @@ void PropertyPanel::showComparePointToolTip(QMouseEvent * event)
             } else if (hasMessage) {
                 customPlot->setToolTip(msg);
             }
+            updateVerticalLine(customPlot, time, value, maxValueAxis);
+            customPlot->replot();
         } else {
             customPlot->setToolTip("Click or 'Ctrl + Click' to highlight charts.");
         }
@@ -3410,9 +3433,30 @@ void PropertyPanel::handleMouseRelease(QMouseEvent * event)
 
 void PropertyPanel::showPointToolTip(QMouseEvent * event)
 {
+    auto updateVerticalLine = [](QCustomPlot* customPlot, double time, double value, double maxValueAxis,
+                                  double latencyValue, double throughputValue) -> void {
+        if (customPlot->verticalLine && customPlot->labelTime && customPlot->labelLatency &&
+            customPlot->labelThroughput && time > 0 && value > 0) {
+
+            customPlot->verticalLine->start->setCoords(time, 0);
+            customPlot->verticalLine->end->setCoords(time, maxValueAxis);
+            // Handle time label at mouse position
+            customPlot->labelTime->setText("Time (ns): " + QString::number(time));
+            customPlot->labelTime->setPositionAlignment(Qt::AlignRight | Qt::AlignBottom);
+            customPlot->labelTime->setRotation(-90);
+            customPlot->labelTime->position->setCoords(time, value);
+            // Handle latency label at mouse position
+            customPlot->labelLatency->setText(QString::number(latencyValue));
+            customPlot->labelLatency->setPositionAlignment(Qt::AlignLeft | Qt::AlignTop);
+            customPlot->labelLatency->position->setCoords(time, latencyValue);
+            // Handle throughput label at mouse position
+            customPlot->labelThroughput->setText(QString::number(throughputValue));
+            customPlot->labelThroughput->setPositionAlignment(Qt::AlignRight | Qt::AlignTop);
+            customPlot->labelThroughput->position->setCoords(time, throughputValue);
+        }
+    };
     // Right-drag and zoom
-    if (rubberBand)
-    {
+    if (rubberBand) {
         rubberBand->setGeometry(QRect(origin, event->pos()).normalized());
         return;
     }
@@ -3423,6 +3467,14 @@ void PropertyPanel::showPointToolTip(QMouseEvent * event)
     {
         QCustomPlot* customPlot = dynamic_cast<QCustomPlot*>(QObject::sender());
         if (!customPlot) return;
+        double time = customPlot->graph(0)->keyAxis()->pixelToCoord(event->localPos().x());
+        double value = customPlot->graph(0)->valueAxis()->pixelToCoord(event->localPos().y());
+        double stepValueAxis = customPlot->graph(0)->valueAxis()->tickStep();
+        if ((value > 0) && (value < stepValueAxis * 2)) value = stepValueAxis * 2;
+        else if ((value > 0) && (value > stepValueAxis * 5)) value = stepValueAxis * 5;
+        double maxValueAxis = customPlot->graph(0)->valueAxis()->range().maxRange;
+        double latencyValue = 0;
+        double throughputValue = 0;
 
         // Find related evengroup
         QSharedPointer<StatTab> statTab = mw->getTabStatTabMap().value(mw->getDisplayPanel()->currentWidget(), nullptr);
@@ -3436,8 +3488,7 @@ void PropertyPanel::showPointToolTip(QMouseEvent * event)
         int graphix = -1, outsidecnt = 0;
         if (!customPlot->axisRect(0) || !customPlot->axisRect(0)->axis(QCPAxis::atBottom, 0)) return;
         auto coord = customPlot->axisRect(0)->axis(QCPAxis::atBottom, 0)->pixelToCoord(event->position().x());
-        for (auto i = 0; i < customPlot->axisRect(0)->axes().size(); i++)
-        {
+        for (auto i = 0; i < customPlot->axisRect(0)->axes().size(); i++) {
             double coordy = customPlot->axisRect(0)->axes()[i]->pixelToCoord(event->position().y());
             graphix = -1;
             QString lbl = customPlot->axisRect(0)->axes()[i]->label();
@@ -3451,17 +3502,22 @@ void PropertyPanel::showPointToolTip(QMouseEvent * event)
                 graphix = 2;
             else if (lbl.contains("Data"))
                 graphix = 0;
-            if (graphix != -1)
-            {
+            if (graphix != -1) {
                 if (customPlot->graphCount() <= graphix || !customPlot->graph(graphix)->data()) return;
                 QCPData dat = customPlot->graph(graphix)->data()->lowerBound(coord).value();
                 float cc = dat.value - coordy;
+                if (graphix == 1) {
+                    if (!eg.showLatency) continue;
+                    latencyValue = dat.value;
+                }
+                if (graphix == 2) {
+                    if (!eg.showThroughput) continue;
+                    throughputValue = dat.value;
+                }
+                if (graphix == 0 && !eg.showDataSize) continue;
+                if (graphix == 3 && !eg.showIdleLatency) continue;
                 if (cc >= 0 && cc <= dat.value / 4) //Inside the graph
                 {
-                    if (graphix == 1 && !eg.showLatency) continue;
-                    if (graphix == 2 && !eg.showThroughput) continue;
-                    if (graphix == 0 && !eg.showDataSize) continue;
-                    if (graphix == 3 && !eg.showIdleLatency) continue;
                     hasMessage = true;
                     msg = msg + lbl + ":";
                     msg = msg + QString::number(dat.value) + "\n";
@@ -3476,6 +3532,7 @@ void PropertyPanel::showPointToolTip(QMouseEvent * event)
         if (hasMessage) //Display the exact value
         {
             customPlot->setToolTip(msg);
+            updateVerticalLine(customPlot, time, value, maxValueAxis, latencyValue, throughputValue);
         }
         else if (outside && outsidecnt >= 3) //Display the graph title
         {
@@ -3483,10 +3540,14 @@ void PropertyPanel::showPointToolTip(QMouseEvent * event)
         }
         else //Display stat table (avg,max,min)
         {
-            eg.get_graphs_points(statTab);
-            QString html = createTableStat(eg);
-            customPlot->setToolTip(html);
+            updateVerticalLine(customPlot, time, value, maxValueAxis, latencyValue, throughputValue);
+            if (!eg.showLegend) {
+                eg.get_graphs_points(statTab);
+                QString html = createTableStat(eg);
+                customPlot->setToolTip(html);
+            }
         }
+        customPlot->replot();
     }
 }
 
@@ -3520,6 +3581,7 @@ void PropertyPanel::updatePlotsStatTab(QWidget * splitter, QSharedPointer<StatTa
         auto customPlot = namePlotMap->value(name);
         setPlotVisible(customPlot, g.enabled);
         if (!g.enabled) continue;
+        bool init = false;
         // Init plot
         if (!customPlot) {
             customPlot = new QCustomPlot();
@@ -3535,6 +3597,8 @@ void PropertyPanel::updatePlotsStatTab(QWidget * splitter, QSharedPointer<StatTa
             // Create widget which include buttons and plot
             auto* plotSplitter = createButtonPlotWidget(customPlot, gl, name, statTab);
             splitter->layout()->addWidget(plotSplitter);
+
+            init = true;
         }
 
         if (customPlotMap.find(name) == customPlotMap.end()) {
@@ -3542,6 +3606,13 @@ void PropertyPanel::updatePlotsStatTab(QWidget * splitter, QSharedPointer<StatTa
             customPlotMap.insert(name, g);
         }
 
+        if (init) {
+            customPlot->initVerticalLine();
+            customPlot->handleLegendTable(g.sumTable_minDataSize, g.sumTable_maxDataSize, g.sumTable_avgDataSize,
+                g.sumTable_minLatency, g.sumTable_maxLatency, g.sumTable_avgLatency,
+                g.sumTable_minThroughput, g.sumTable_maxThroughput, g.sumTable_avgThroughput);
+        }
+
         // Reset map title
         QString graphName = QString::fromStdString(gl);
         int graphNameLimit = 50;
@@ -3590,6 +3661,7 @@ void PropertyPanel::updatePlotsStatTab(QWidget * splitter, QSharedPointer<StatTa
             // Add to bottom of main layout
             splitter->layout()->addWidget(plotSplitter);
             customPlot->setToolTip(wrapTextForTooltip(QString::fromStdString(p.name), plotTooltipWrap));
+            customPlot->initVerticalLine();
         }
         updateComparisonPlot(statTab, p, name, customPlot);
     }
@@ -3789,6 +3861,9 @@ GraphSplitter* PropertyPanel::createButtonPlotWidget(QCustomPlot * customPlot, c
     INICheckBox* showLegend = new INICheckBox("Legend", QString::fromStdString(gl), fullName);
     showLegend->setCheckState(Qt::Checked);
 
+    INICheckBox* showVerticalLine = new INICheckBox("Vertical Line", QString::fromStdString(gl), fullName);
+    showVerticalLine->setCheckState(Qt::Checked);
+
     zoomInGraph->setAutoDefault(false);
     zoomInGraph->setDefault(false);
     zoomOutGraph->setAutoDefault(false);
@@ -3828,6 +3903,7 @@ GraphSplitter* PropertyPanel::createButtonPlotWidget(QCustomPlot * customPlot, c
     zoomButtonlayout->addWidget(showThroughput);
     zoomButtonlayout->addWidget(showIdleLatency);
     zoomButtonlayout->addWidget(showLegend);
+    zoomButtonlayout->addWidget(showVerticalLine);
     zoomButtonlayout->addWidget(binInterval);
     zoomButtonlayout->addWidget(binIntervalLabel);
     zoomButtonlayout->addWidget(binSize);
@@ -3846,6 +3922,7 @@ GraphSplitter* PropertyPanel::createButtonPlotWidget(QCustomPlot * customPlot, c
     connect(showThroughput, SIGNAL(clicked(bool)), this, SLOT(showGraphInNomarPlot(bool)));
     connect(showIdleLatency, SIGNAL(clicked(bool)), this, SLOT(showGraphInNomarPlot(bool)));
     connect(showLegend, SIGNAL(clicked(bool)), this, SLOT(showGraphInNomarPlot(bool)));
+    connect(showVerticalLine, SIGNAL(clicked(bool)), this, SLOT(showGraphInNomarPlot(bool)));
 
     connect(startTime, SIGNAL(editingFinished()), this, SLOT(binSizeChangedInNormarPlot()));
     connect(binSize, SIGNAL(editingFinished()), this, SLOT(binSizeChangedInNormarPlot()));
@@ -3906,6 +3983,9 @@ GraphSplitter* PropertyPanel::createComparisonPlotWidget(QCustomPlot * customPlo
     if (plot->throughput) showThroughput->setCheckState(Qt::Checked);
     else showThroughput->setCheckState(Qt::Unchecked);
 
+    INICheckBox* showVerticalLine = new INICheckBox("Vertical Line", QString::fromStdString(gl), fullName);
+    showVerticalLine->setCheckState(Qt::Checked);
+
     QString tooltip = "Start time is the time at which the performance stats currently displayed in the plot begins. If start time is 109 and zoom level is for 1000ns, then performance stats between 109ns and 1109ns would be displayed.";
     INILineEdit* startTime = new INILineEdit(QString::number((long)plot->zoomLower), QString::fromStdString(gl), fullName, INILineEdit::StartTime);
     startTime->setMaximumWidth(textInputLength);
@@ -3932,6 +4012,7 @@ GraphSplitter* PropertyPanel::createComparisonPlotWidget(QCustomPlot * customPlo
     zoomButtonlayout->addWidget(showLatency);
     zoomButtonlayout->addWidget(showPkt);
     zoomButtonlayout->addWidget(showThroughput);
+    zoomButtonlayout->addWidget(showVerticalLine);
     zoomButtonlayout->addWidget(binInterval);
     zoomButtonlayout->addWidget(binIntervalLabel);
     zoomButtonlayout->addWidget(binSize);
@@ -3948,6 +4029,7 @@ GraphSplitter* PropertyPanel::createComparisonPlotWidget(QCustomPlot * customPlo
     connect(showLatency, SIGNAL(clicked(bool)), this, SLOT(showGraphInComparePlot(bool)));
     connect(showPkt, SIGNAL(clicked(bool)), this, SLOT(showGraphInComparePlot(bool)));
     connect(showThroughput, SIGNAL(clicked(bool)), this, SLOT(showGraphInComparePlot(bool)));
+    connect(showVerticalLine, SIGNAL(clicked(bool)), this, SLOT(showGraphInComparePlot(bool)));
 
     connect(startTime, SIGNAL(editingFinished()), this, SLOT(binSizeChangedInComparePlot()));
     connect(binSize, SIGNAL(editingFinished()), this, SLOT(binSizeChangedInComparePlot()));
@@ -4529,16 +4611,29 @@ void PropertyPanel::showGraphInNomarPlot(bool show)
     std::map<group_label, EventGroup>* evenGroups = &statTab->groups;
     EventGroup& eg = evenGroups->at(checkBox->getEventGroupName().toStdString());
     if (checkBox->text() == "Apply To All") eg.applyToAll = show;
-    if (checkBox->text() == "Latency") eg.showLatency = show;
     if (checkBox->text() == "Data Size") eg.showDataSize = show;
-    if (checkBox->text() == "Throughput") eg.showThroughput = show;
     if (checkBox->text() == "Idle Latency") eg.showIdleLatency = show;
     // Get and update plot in current widget
     QCustomPlot * cPlot = plotMap->value(checkBox->getEventGroupName(), nullptr);
     if (!cPlot) return;
     if (checkBox->text() == "Legend") {
+        eg.showLegend = show;
         cPlot->legend->setVisible(show);
     }
+    if (checkBox->text() == "Latency") {
+        eg.showLatency = show;
+        cPlot->labelLatency->setVisible(show);
+    }
+    if (checkBox->text() == "Throughput") {
+        eg.showThroughput = show;
+        cPlot->labelThroughput->setVisible(show);
+    }
+    if (checkBox->text() == "Vertical Line") {
+        cPlot->verticalLine->setVisible(show);
+        cPlot->labelTime->setVisible(show);
+        cPlot->labelLatency->setVisible(show);
+        cPlot->labelThroughput->setVisible(show);
+    }
     updateNormalPlot(statTab, eg, cPlot, true);
     cPlot->replot();
 }
@@ -5178,6 +5273,10 @@ void PropertyPanel::showGraphInComparePlot(bool show)
     // Get and update plot in focusing widget
     QCustomPlot * cplot = plotMap->value(checkBox->getEventGroupName(), nullptr);
     if (!cplot) return;
+    if (checkBox->text() == "Vertical Line") {
+        cplot->verticalLine->setVisible(show);
+        cplot->labelTime->setVisible(show);
+    }
     updateComparisonPlot(statTab, plot, checkBox->getEventGroupName(), cplot);
 }
 
diff --git a/src/sw/noc_dev/prototype_qt6/Utils/stattab.h b/src/sw/noc_dev/prototype_qt6/Utils/stattab.h
index 4d340e34a7e..fc441e65cae 100644
--- a/src/sw/noc_dev/prototype_qt6/Utils/stattab.h
+++ b/src/sw/noc_dev/prototype_qt6/Utils/stattab.h
@@ -48,6 +48,7 @@ struct EventGroup {
     bool showDataSize = true;
     bool showThroughput = true;
     bool showIdleLatency = true;
+    bool showLegend = true;
     double zoomLower = 0;
     double zoomUpper = 10000;
     bool showLatencyHistogram = false;
